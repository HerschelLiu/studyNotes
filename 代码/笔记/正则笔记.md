**正则是匹配模式，要么匹配字符，要么匹配位置**

### 字符组

需要强调的是，虽叫字符组（字符类），但只是其中一个字符。例如`[abc]`，表示匹配一个字符，它可以是“a”、“b”、“c”之一。

#### 范围表示法

如果字符组里的字符特别多的话，怎么办？可以使用范围表示法。

比如`[123456abcdefGHIJKLM]`，可以写成`[1-6a-fG-M]`。用连字符`-`来省略和简写。

匹配“a”、“-”、“z”这三者中任意一个字符使用`[-az]`或`[az-]`或`[a\-z]`。

### 正则表达式位置匹配攻略

#### 2.1 ^和$

^匹配开头；$匹配结尾

#### 2.2 \b和\B

`\b`是单词边界，具体就是`\w`和`\W`之间的位置，也包括`\w`和`^`之间的位置，也包括`\w`和`$`之间的位置。

比如一个文件名是"[JS] Lesson_01.mp4"中的`\b`，如下：

```js
var result = "[JS] Lesson_01.mp4".replace(/\b/g, '#');
console.log(result); // => "[#JS#] #Lesson_01#.#mp4#"
```

为什么是这样呢？这需要仔细看看。

首先，我们知道，`\w`是字符组`[0-9a-zA-Z_]`的简写形式，即`\w`是字母数字或者下划线的中任何一个字符。而`\W`是排除字符组`[^0-9a-zA-Z_]`的简写形式，即`\W`是`\w`以外的任何一个字符。

此时我们可以看看"[#JS#] #Lesson_01#.#mp4#"中的每一个"#"，是怎么来的。

- 第一个"#"，两边是"["与"J"，是`\W`和`\w`之间的位置。
- 第二个"#"，两边是"S"与"]"，也就是`\w`和`\W`之间的位置。
- 第三个"#"，两边是空格与"L"，也就是`\W`和`\w`之间的位置。
- 第四个"#"，两边是"1"与"."，也就是`\w`和`\W`之间的位置。
- 第五个"#"，两边是"."与"m"，也就是`\W`和`\w`之间的位置。
- 第六个"#"，其对应的位置是结尾，但其前面的字符"4"是`\w`，即`\w`和`$`之间的位置。

知道了`\b`的概念后，那么`\B`也就相对好理解了。

`\B`就是`\b`的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉`\b`，剩下的都是`\B`的。

具体说来就是`\w`与`\w`、`\W`与`\W`、`^`与`\W`，`\W`与`$`之间的位置。

#### 2.3 (?=p)和(?!p)

`(?=p)正向先行断言`，其中`p`是一个子模式，即`p`前面的位置。

比如`(?=l)`，表示'l'字符前面的位置。例如：

```js
var result = "hello".replace(/(?=l)/g, '#');
console.log(result); // => "he#l#lo"
```

而`(?!p)负向先行断言`就是`(?=p)`的反面意思，比如：

```js
var result = "hello".replace(/(?!l)/g, '#');
console.log(result); // => "#h#ell#o#"
```

ES6中还支持`(?<=p)`和`(?<!p)`

> `(?=.*[0-9])`
>
> * `.`符号用来查找除了换行符和行结束符以外的任意单个字符
> * `*`表示0至∞
>
> 组合在一起就是**接下来的字符，必须包含个数字**。

### 分组(ab)+和分支结构(a|b)

即`()`的用法。有了它，我们就可以进行数据提取，以及更强大的替换操作

`match`返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标（首次匹配到子字符的位置），最后是输入的文本（input）。（注意：如果正则是否有修饰符`g`，`match`返回的数组格式是不一样的）。

例如：

```js
const reg1 = /\d{4}-\d{2}-\d{2}/;
const reg2 = /(\d{4})-(\d{2})-(\d{2})/;
const string = '2020-10-09';
// reg1和reg2都是匹配年月日的，不同点在于reg2的输出结果会多出每个括号的匹配结果
console.log(string.match(reg1)); // ["2020-10-09", index: 0, input: "2020-10-09", groups: undefined]
console.log(string.match(reg2)); // ["2020-10-09", "2020", "10", "09", index: 0, input: "2020-10-09", groups: undefined]

// 也可以使用构造函数的全局属性$1至$9指定
console.log(RegExp.$1); // "2020"
console.log(RegExp.$2); // "10"
console.log(RegExp.$3); // "09"
```

#### 替换

```js
const reg = /(\d{4})-(\d{2})-(\d{2})/;
const string = '2020-10-09';
let result = string.replace(reg, '$2/$3/$1');
console.log(result) // => "10/09/2020"
```

#### 反向引用

除了使用相应API来引用分组，也可以在正则本身里引用分组。对车能引用之前出现的分组。

例如：

```js
/*
 写一个正则支持以下三种格式
 2020-10-09
 2020/10/09
 2020.10.09
*/
const reg1 = /\d{4}(-|\/|\.)\d{2}(-|\/|\.)\d{2}/; // 最先想到的
/*
 虽然匹配了要求的情况，但也匹配"2016-06/12"这样的数据。
 假设我们想要求分割符前后一致怎么办？此时需要使用反向引用
*/

const reg2 = /\d{4}(-|\/|\.)\d{2}\1\d{2}/;
/*
 \1表示之前的分组(-|\/|\.)。不管它匹配到什么（比如-），\1都匹配那个同样的具体某个字符。\2\3同理，以此类推（\10是表示第10个分组）
*/

// 括号嵌套
const regex = /^((\d)(\d(\d)))\1\2\3\4$/;
const string = "1231231233";
console.log(regex.test(string)); // true
console.log(RegExp.$1); // 123
console.log(RegExp.$2); // 1
console.log(RegExp.$3); // 23
console.log(RegExp.$4); // 3

/*
 引用不存在的分组，正则不报错，而是把不存在分组的引用变为其本身含义，假如不存在/2，则匹配‘/2’，即2的转义
*/
```

### 非捕获分组

之前出现的分组，都会捕获它们匹配到的数据，以便后续引用，因此也称他们是捕获型分组。

如果只想要括号最原始的功能，但不会引用它，即，既不在API里引用，也不在正则里反向引用。此时可以使用非捕获分组`(?:p)`

```js
const reg = /(?:\d{4})-(?:\d{2})-(?:\d{2})/;
const string = '2020-10-09';
console.log(string.match(reg)); // ["2020-10-09", "2020", "10", "09", index: 0, input: "2020-10-09", groups: undefined]
console.log(RegExp.$1); // ""
console.log(RegExp.$2); // ""
console.log(RegExp.$3); // ""
```

### 正则基础之——NFA引擎匹配原理

>  引用自[正则基础之——NFA引擎匹配原理](https://blog.csdn.net/lxcnn/article/details/4304651)

正则引擎大体上可分为不同的两类：*DFA*和*NFA*，而*NFA*又基本上可以分为传统型*NFA*和*POSIX NFA*。

*DFA Deterministic finite automaton* 确定型有穷自动机

*NFA Non-deterministic finite automaton*　非确定型有穷自动机

*DFA*引擎因为不需要回溯，所以匹配快速，但不支持捕获组，所以也就不支持反向引用和*$number*这种引用方式，目前使用*DFA*引擎的语言和工具主要有*awk*、*egrep* 和 *lex*。

*POSIX NFA*主要指符合*POSIX*标准的*NFA*引擎，它的特点主要是提供*longest-leftmost*匹配，也就是在找到最左侧最长匹配之前，它将继续回溯。同*DFA*一样，非贪婪模式或者说忽略优先量词对于*POSIX NFA*同样是没有意义的。

#### 字符串组成

`[0]a[1]b[2]c[3]`

`[number]`指代位置，即位置0、位置1、位置2、位置3

#### 占有字符和零宽度

正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是零宽度的。

占有字符是互斥的，零宽度是非互斥的。也就是一个字符，同一时间只能由一个子表达式匹配，而一个位置，却可以同时由多个零宽度的子表达式匹配。

#### 控制权和传动

正则的匹配过程，通常情况下都是由一个子表达式（可能为一个普通字符、元字符或元字符序列组成）取得控制权，从字符串的某一位置开始尝试匹配，一个子表达式开始尝试匹配的位置，是从前一子表达匹配成功的结束位置开始的。

***(子表达式1)(子表达式2)***

假设***(子表达式1)***为零宽度表达式，由于它匹配开始和结束的位置是同一个，如位置*0*，那么***(子表达式2)***是从位置*0*开始尝试匹配的。

假设***(子表达式1)***为占有字符的表达式，由于它匹配开始和结束的位置不是同一个，如匹配成功开始于位置*0*，结束于位置*2*，那么***(子表达式2)***是从位置*2*开始尝试匹配的。

而对于整个表达式来说，通常是由字符串位置*0*开始尝试匹配的。如果在位置*0*开始的尝试，匹配到字符串某一位置时整个表达式匹配失败，那么引擎会使正则向前传动，整个表达式从位置*1*开始重新尝试匹配，依此类推，直到报告匹配成功或尝试到最后一个位置后报告匹配失败。

#### 匹配过程

##### 基础匹配过程

源字符`[0]a[1]b[2]c[3]`用$表示，正则表达式abc，指针为p

`p -> [0]`，表达式a取得控制权，a匹配$a。成功

`p -> [1]`，表达式b取得控制权，b匹配$b。成功

`p -> [2]`，表达式c取得控制权，c匹配$c。成功

`p -> [3]`，完成

匹配成功，`match[0] = 'abc'`，开始位置0，结束位置3

#####  含有匹配优先量词(? 先进行匹配)的匹配过程——匹配成功（一）

源字符`[0]a[1]b?[2]c[3]`用$表示，正则表达式ab?c，指针为p

`p -> [0]`，表达式a取得控制权，a匹配$a。成功

`p -> [1]`，表达式b?取得控制权，b尝试匹配$b。成功

`p -> [1]`，表达式c取得控制权，c匹配$c。成功

`p -> [2]`，完成

匹配成功，`match[0] = 'abc'`，开始位置0，结束位置3

##### 含有匹配优先量词的匹配过程——匹配成功（二）

源字符``[0]a[1]b[2]d[3]``用$表示，正则表达式ab?c，指针为p

`p -> [0]`，表达式a取得控制权，a匹配$a。成功

`p -> [1]`，表达式b?取得控制权，b尝试匹配$b。成功

`p -> [2]`，表达式c取得控制权，c匹配$d。失败

`p -> [1]`，表达式b?取得控制权，b尝试匹配$b。成功

`p -> [3]`，完成

匹配成功，`match[0] = 'ac'`，开始位置0，结束位置3

##### 含有匹配优先量词的匹配过程——匹配失败

源字符``[0]a[1]b[2]d[3]``用$表示，正则表达式ab?c，指针为p

`p -> [0]`，表达式a取得控制权，a匹配$a。成功

`p -> [1]`，表达式b?取得控制权，b尝试匹配$b。成功

`p -> [2]`，表达式c取得控制权，c匹配$d。失败

`p -> [1]`，表达式b?取得控制权，b尝试匹配$b。忽略

`p -> [1]`，表达式c取得控制权，c尝试匹配$b。失败

`p -> [1]`，完成

第一轮匹配失败

`p -> [1]`，表达式a取得控制权，a匹配$b。失败

`p -> [1]`，完成

第二轮匹配失败

结果：失败

##### 含有忽略优先量词（?? 先进行不匹配）的匹配过程——匹配成功

源字符``[0]a[1]b[2]c[3]``用$表示，正则表达式ab??c，指针为p

`p -> [0]`，表达式a取得控制权，a匹配$a。成功

`p -> [1]`，表达式b?？取得控制权，b尝试匹配$b。忽略

`p -> [2]`，表达式c取得控制权，c匹配$b。失败

`p -> [1]`，表达式b??取得控制权，b尝试匹配$b。成功

`p -> [2]`，表达式c取得控制权，c尝试匹配$c。成功

`p -> [3]`，完成

匹配成功，`match[0] = 'abc'`，开始位置0，结束位置3

##### 零宽度匹配过程

**零宽度的子表达式之间是不互斥的，即同一个位置可以同时由多个零宽度子表达式匹配**

源字符``[0]a[1]1[2]2[3]``用$表示，正则表达式`^(?=[a-z])[a-z0-9]+\$`，指针为p

`p -> [0]`，表达式`^`取得控制权，`^`匹配[0]。成功

`p -> [0]`，表达式`(?=[a-z])`取得控制权，`(?=[a-z])`尝试匹配$a。成功

`p -> [0]`，表达式`[a-z0-9]+`取得控制权，`[a-z0-9]+`匹配$a。成功

`p -> [1]`，表达式`[a-z0-9]+`取得控制权，`[a-z0-9]+`尝试匹配$1。成功

`p -> [2]`，表达式`[a-z0-9]+`取得控制权，`[a-z0-9]+`尝试匹配$2。成功

`p -> [3]`，表达式`\$`取得控制权，`\$`匹配[3]。成功

`p -> [3]`，完成

匹配成功，`match[0] = 'a12'`，开始位置0，结束位置3，`^` 、`(?=[a-z])`匹配[0]，`[a-z0-9]+`匹配a12， `\$`匹配[3]