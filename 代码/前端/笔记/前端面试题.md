## 防抖与节流

**防抖**：触发高频事件后，n秒内函数只会执行一次，如果 n秒内高频事件再次触发，则重新计算时间，也就是说在一定时间内只会执行一次操作

**节流**：高频事件触发，n秒内只会执行一次，所以节流会稀释函数执行频率



## 网页从输入 url 到页面加载发生了什么

1. URL解析：url 包括协议（http、https）、主机名、端口号、路径、查询参数等信息
2. DNS 解析：浏览器需要将主机名解析为对应 ip 地址，浏览器会查询本地DNS 缓存，如果没有找到，回想 DNS 服务器发送请求进行解析
3. 建立连接：浏览器使用解析得到的 IP地址和服务器建立 TCP 连接，这个过程通常是通过三次握手来确保双方能够正常通信。
4. 发起请求：建立连接后，浏览器向服务器发送 HTTP 请求
5. 服务器响应：浏览器接收到请求后，处理请求并生成相应的响应数据。
6. 浏览器接收响应：浏览器接收到服务器的响应数据，并根据响应头中的信息进行处理。
7. 解析和渲染页面：浏览器开始解析响应数据，如果是 html 页面，浏览器会解析 HTML 标记，并构建 DOM 树。同时，浏览器还会解析 CSS 样式和 Javascript 代码，构建 css 和执行 Javascript。这些过程中会生成渲染树，用于最终的页面渲染。
8. 页面渲染：根据生成的渲染树和布局计算，浏览器开始将页面内容显示在用户屏幕上。包括绘制像素、处理图像、执行动画等过程。
9. 完成加载



## JS 原型链有什么特点

继承



## cookie 和 localStorage

1. cookie数据会发给服务器，storage 只存本地
2. cookie4k，storage 为5M
3. 有效期不同，cookie 在设置的过期时间之前一直有效，storage 仅在关闭窗口或浏览器之前有效

## vue 组件的 data 为什么是个函数

写成函数这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创造一个私有的刷数据空间，让每个组件实例维护各自的数据。写成对象会使得所有组件实例复用一份 data。



## 深拷贝和浅拷贝，如何实现深拷贝

是指在赋值对象时，是否对其内部的子对象进行递归复制。

可以使用`JSON.parse`、`JSON.stringify`、递归复制



## vue 的监听属性和计算属性有什么区别

都用于检测数据变化，但是监听属性是一个函数，需要手动调用，而计算属性是一个属性，会自动计算并缓存结果



## 大文件上传

1. 将大文件切分为固定大小（如 5MB/片），降低单次请求压力

```js
const chunkSize = 5 * 1024 * 1024; // 5MB
const chunks = [];
for (let i = 0; i < file.size; i += chunkSize) {
  chunks.push(file.slice(i, i + chunkSize));
}
```

2. 前端上传分片不用管分片顺序，切分时，chunks数组中每个分片包含文件 hash（使用spark-md5生成），当前分片索引以及总分片数。
3. 使用 `Promise.all` 或 `axios` 并发上传分片，但需限制并发数（如 3-5个），避免浏览器阻塞。服务端按分片顺序合并文件（通过唯一 hash 标识关联）。
4. 断点续传。
5. 前端生成文件唯一标识（如 `SparkMD5` 计算文件 hash），服务端记录已上传分片索引。上传前先查询已传分片，跳过重复上传。
6. 文件校验。上传完成后，服务端校验合并文件的完整性（对比 MD5 或文件大小）。前端提供重试机制：失败分片自动重新上传。
7. 进度监控。通过 `axios` 的 `onUploadProgress` 或 `fetch` + `TransformStream` 实时计算总进度。

加分细节：

- **Web Worker**：将文件分片、hash 计算放入 Worker，避免主线程卡顿。
- **HTTP/2 多路复用**：提升分片上传效率（需服务端支持）。
- **内存优化**：使用 `FileReader.readAsArrayBuffer` 流式读取大文件，避免内存爆增。
- **秒传机制**：服务端通过 hash 判断文件已存在，直接返回 URL，无需上传。
- **如何验证合并后的文件完整性**：前端在分片前计算文件的完整 MD5，合并后服务端校验最终文件的 MD5 是否匹配。同时检查文件大小是否符合预期。

## 页面截图

主要使用 html2canvas

将页面转化为 canvas

## 同一个链接实现打开不同应用，pc 打开是 web 应用，手机打开是 h5

**核心思路**：通过 **设备类型检测（User-Agent）** 结合 **响应式路由/动态渲染**，实现同一 URL 按设备类型分发不同内容。**User-Agent 解析**：服务端（如 Nginx/Node.js）根据请求头中的 `User-Agent` 判断设备类型（PC/Mobile）。

**前端动态渲染（CSR）**

- **条件渲染**：在单页应用（如 React/Vue）中，通过 `window.navigator.userAgent` 检测设备类型，动态加载对应组件。

## 前端水印功能

页面水印：MutationObserver，监听元素变化

## [你给我讲讲async/await](https://zhuanlan.zhihu.com/p/1928835813761856366)

“async/await 是 Generator 的语法糖，通过状态机和 Promise 实现‘异步转同步’：

1. await 暂停函数，返回 Promise → ⏸️ 状态保存
2. Promise 完成后恢复执行 → 事件循环调度
3. 代码顺序与逻辑顺序一致，但本质仍为异步 → 非阻塞”

作者：前端充电站
链接：https://zhuanlan.zhihu.com/p/1928835813761856366
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。