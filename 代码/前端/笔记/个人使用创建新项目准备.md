## 插件

```bash
pnpm add normalize.css unocss

pnpm add -D @types/node prettier

pnpm init @eslint/config #按操作选择

# react
pnpm add zustand classnames
```





## 各文件配置

### `prettier`

```bash
pnpm add -D eslint-plugin-prettier prettier eslint-config-prettier
```



`.prettierrc`

```json
  {
    // 使用单引号包裹字符串
    "singleQuote": true,

    // 语句末尾添加分号
    "semi": false,

    // 保持花括号之间的间隔
    "bracketSpacing": true,

    // 不在参数周围添加额外的花括号
    "trailingComma": "none",

    // 不在行末尾与花括号在同一行
    "bracketSameLine": false,

    // 避免在箭头函数周围添加额外的花括号
    "arrowParens": "avoid",

    // 根据代码的内容自动设置行尾方式
    "endOfLine": "auto",

    // 屏幕宽度超过150字符时折叠代码
    "printWidth": 150,

    // 忽略HTML空白字符
    "htmlWhitespaceSensitivity": "ignore",

    // 覆盖设置
    "overrides": [
      {
        "files": "*.wxml",
        "options": {
          "parser": "html"
        }
      },
      {
        "files": "*.html",
        "options": {
          "parser": "html"
        }
      },
      {
        "files": "*.vue",
        "options": {
          "parser": "vue"
        }
      },
      {
        "files": "*.tsx",
        "options": {
          "parser": "typescript"
        }
      }
    ]
  }
```

`package.json`

```json
{
  ...
  "lint-staged": {
    "miniprogram/**/*.scss": [
      "stylelint --fix --allow-empty-input"
    ]
  }
}
```



如果搭配 eslint 还需要安装`eslint-plugin-prettier`

```json
// eslintrc
...
"extends": {
  ...
  "plugin:prettier/recommended",
}
"rules": {
  ...
  "prettier/prettier": "error",
}
```





### stylelint

[Stylelint 简介 | Stylelint中文文档 | Stylelint中文网](https://www.stylelint.com.cn/)

```bash
pnpm add -D stylelint stylelint-config-standard stylelint-order stylelint-config-property-sort-order-smacss stylelint-prettier
```

`scss`: `stylelint-config-standard-scss`

如果使用 css 预编译器要加上`stylelint-config-css-modules`

> 将SCSS与诸如styleslint -config-standard- SCSS之类的配置一起使用意味着您必须安装styleslint - SCSS。
>
> Plugins: [“"stylelint-scss"”]

* `stylelint`：StyleLint 的核心模块
* `stylelint-config-standard`：StyleLint 官方推荐的配置规则
* `stylelint-config-standard-scss`：该插件是 StyleLint 的 SCSS 扩展，增加了对 SCSS 语法的支持，允许检查和验证 SCSS 文件
* ` stylelint-order`： 该插件提供了一套默认的CSS 属性排序规则，可以按照指定的顺序对属性进行排序。它可以让你自定义属性的排序顺序；配置在plugins
* `stylelint-config-recess-order` 是一个 Stylelint 共享配置，提供了基于 [Recess](http://twitter.github.io/recess/) 项目的属性排序顺序。它是一种现成的排序规则，你只需扩展它即可，不需要额外的详细配置，适合那些不需要自定义排序顺序的用户。配置在extends
* `stylelint-config-property-sort-order-smacss`： 基于 [SMACSS](http://smacss.com/) 方法排序的stylelint配置

* 需要先安装`prettier`
  * `stylelint-prettier`：基于 `prettier` 代码风格的 `stylelint` 规则
  * `stylelint-config-prettier`：该配置用于解决 StyleLint 和 Prettier 之间的规则冲突问题。将其放在 `extends` 数组的最后位置，可以确保覆盖 Prettier 的配置

> 16版本中启用了大量规则，所以不再需要"stylelint-config-prettier",[迁移到 15.0.0 |斯泰林特 (stylelint.io)](https://stylelint.io/migration-guide/to-15/)，14及以下还是需要的

`.stylelintrc`

```json
{
  "plugins": ["stylelint-order", "stylelint-prettier"],
  "extends": [
    "stylelint-config-standard",
    "stylelint-config-standard-scss",
    "stylelint-config-prettier",
    "stylelint-config-property-sort-order-smacss"
    "stylelint-config-css-modules"
  ],
  "rules": {
    // 检查未知的 at-rules
    "at-rule-no-unknown": [
      true,
      {
        "ignoreAtRules": ["mixin", "include", "extend", "import", "if"]
      }
    ],
    // 要求或禁止在声明语句之前有空行
    "declaration-empty-line-before": "never",
    // 禁止低优先级的选择器出现在高优先级的选择器之后
    "no-descending-specificity": null,
    // 禁止未知的伪元素选择器
    "selector-pseudo-element-no-unknown": [
      true,
      {
        "ignorePseudoElements": ["v-deep"]
      }
    ],
    // 禁止未知的伪类选择器
    "selector-pseudo-class-no-unknown": [
      true,
      {
        "ignorePseudoClasses": ["deep"]
      }
    ],
    // 禁止未知的单位
    "unit-no-unknown": [
      true,
      {
        "ignoreUnits": ["/rpx/"]
      }
    ],
    // 禁止未知的类型选择器
    "selector-type-no-unknown": [
      true,
      {
        "ignoreTypes": [
          "/page/"
        ]
      }
    ],
    // 禁止自定义属性缺少 var 函数
    "custom-property-no-missing-var-function": [
      true,
      {
        "ignoreAtRules": ["$"]
      }
    ],
    // 使用 Prettier 格式化代码
    "prettier/prettier": [
      true
    ],
    // 禁止未知的函数
    "function-no-unknown": [
      true,
      {
        "ignoreFunctions": ["constant", "env"]
      }
    ],
    // 禁止使用厂商前缀
    "value-no-vendor-prefix": null,
    // 为适用的颜色功能指定现代或传统符号
    "color-function-notation": "legacy",
    // 按照指定顺序进行检查
    "order/order": [
      "at-rules",
      "declarations",
      "rules",
      "dollar-variables",
      "custom-properties"
    ],
    // 指定 alpha 值的百分比或数字表示法
    "alpha-value-notation": null
  }
}
```

`.stylelintignore`为忽略文件

```
dist/*.js
src/assets
node_modules
index.html
public

```

`package.json`

```json
// 小程序
{
  "scripts": {
    "lint:stylelint": "stylelint \"./miniprogram/**/*.scss\" --fix"
  }
}

// 
"lint:stylelint": "stylelint \"./src/**/*.{scss,vue}\" --fix",
```





### `eslint`



### vite

```ts
import { defineConfig, loadEnv } from 'vite'
import react from '@vitejs/plugin-react'
import { resolve } from 'path'
// import { visualizer } from 'rollup-plugin-visualizer' // vite打包分析插件,需要install

// https://vitejs.dev/config/
export default ({ mode }) => {
  const env = loadEnv(mode, process.cwd()) // vite配置文件使用env， 主要用于管理和注入环境变量。process.cwd()返回项目的根目录路径。这样可以确保根据不同的构建模式加载相应的环境变量。
  
  // 全局变量
  const define = {}
  if (mode !== 'development') define['process.platform'] = 'win32' // 这可能是因为某些代码逻辑依赖于特定的操作系统平台。
  else define['process.env'] = process.env
  
  return defineConfig({
    base: env.VITE_APP_BASE_URL, // 需要.env文件
    define, // 定义全局常量替换方式。其中每项在开发环境下会被定义在全局，而在构建时被静态替换。
    resolve: {
      alias: {
        '@': resolve(__dirname, './src')
      }
    },
    /** https://cn.vitejs.dev/config/build-options.html */
    build: {
      terserOptions: {
        compress: {
          drop_console: true, // 构建时删除调用console
          drop_debugger: true // 构建时删除调用debugger
        }
      },
      minify: 'terser',
      // cssCodeSplit: true, // 启用/禁用 CSS 代码拆分,默认为 true
      assetsInlineLimit: 1024 * 1, // 小于此阈值的导入或引用资源将内联为 base64 编码，以避免额外的 http 请求。设置为 0 可以完全禁用此项。
    },
    plugins: [
      react()，
      /* stats.html */
      // visualizer()
    ],
  })
}

```

Build.minify设置为 `false` 可以禁用最小化混淆，或是用来指定使用哪种混淆器。默认为 [Esbuild](https://github.com/evanw/esbuild)，它比 terser 快 20-40 倍，压缩率只差 1%-2%。[Benchmarks](https://github.com/privatenumber/minification-benchmarks)

注意，在 lib 模式下使用 `'es'` 时，`build.minify` 选项不会缩减空格，因为会移除掉 pure 标注，导致破坏 tree-shaking。

当设置为 `'terser'` 时必须先安装 Terser。



```
npm add -D terser
```

> import.meta.env 和 loadEnv 的使用场景不同
> import.meta.env 是在运行时获取环境变量的值，适用于应用程序代码中需要动态获取环境变量的场合。（配置文件中获取不到，因为配置文件是在构建时被读取！！！）
>
> 而 loadEnv 则是在构建时加载环境变量，适用于打包时（构建时）需要引用环境变量的场合。

#### [TypeScript 的智能提示](https://cn.vitejs.dev/guide/env-and-mode#intellisense)

默认情况下，Vite 在 [`vite/client.d.ts`](https://github.com/vitejs/vite/blob/main/packages/vite/client.d.ts) 中为 `import.meta.env` 提供了类型定义。随着在 `.env[mode]` 文件中自定义了越来越多的环境变量，你可能想要在代码中获取这些以 `VITE_` 为前缀的用户自定义环境变量的 TypeScript 智能提示。

要想做到这一点，你可以在 `src` 目录下创建一个 `vite-env.d.ts` 文件，接着按下面这样增加 `ImportMetaEnv` 的定义：

typescript

```
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_APP_TITLE: string
  // 更多环境变量...
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}
```



### tsconfig

```json
// tsconfig.json
{
  "compilerOptions": {
    ...
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "src/*"
      ]
    }
  }
}
```

> 在使用vite生成tsconfig.json,tsconfig.app.json,tsconfig.node.json这三个文件,其中tsconfig.node.json是专门用来配置vite.config.ts文件的编译规则,tsconfig.app.json则是用来定义项目中其他文件的ts编译规则,后面两个文件最终会被引入到tsconfig.json中.



### unocss

查看 react.md



### sass

```bash
npm install -D sass sass-loader
```



```ts
// vite.config
...
css: {
    preprocessorOptions: {
      scss: {
        additionalData: '@import "@/styles/variables.scss";' // 需要有相应文件
      }
    }
  }
```

