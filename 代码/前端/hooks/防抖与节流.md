## 代码

**防抖**

```ts
/** 防抖 */
const debounceMap = new Map<Function, NodeJS.Timeout>()

export function useDebounce(func: Function, wait = 1000, immediate = false) {
  const timeout = debounceMap.get(func)
  if (timeout) {
    clearTimeout(timeout)
  }

  if (immediate && !timeout) {
    func()
  }

  const newTimeout = setTimeout(() => {
    debounceMap.delete(func)
    if (!immediate) {
      func()
    }
  }, wait)

  debounceMap.set(func, newTimeout)
}
```

* immediate用来决定是否要第一次立即执行



**节流**

```tsx

/** 节流 */
const throttleMap = new Map<Function, boolean>()

export function useThrottle(func: Function, wait = 1000) {
  if (!throttleMap.get(func)) {
    func()
    throttleMap.set(func, true)
    setTimeout(() => {
      throttleMap.delete(func)
    }, wait)
  }
}

```

## 异同

### 核心区别

|   特性   |                       防抖（Debounce）                       |                       节流（Throttle）                       |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 执行逻辑 | 事件触发后，延迟执行函数；若延迟期间再次触发，则重新计时，最终只执行最后一次触发 | 事件触发后，固定时间间隔内最多执行一次函数，后续触发在间隔期内被忽略 |
|  关注点  |           确保高频事件结束后仅执行一次（结果导向）           |            确保高频事件按固定频率执行（过程导向）            |
| 应用场景 |             输入框搜索联想、窗口大小调整后的计算             |             页面滚动加载、鼠标移动事件（如拖拽）             |

### 适用场景

|         场景         | 选择技术 |                       原因                       |
| :------------------: | :------: | :----------------------------------------------: |
|    输入框实时搜索    |   防抖   |   用户停止输入后才发送请求，避免频繁请求服务器   |
|   页面滚动加载更多   |   节流   | 按固定频率检查滚动位置，避免高频触发导致性能问题 |
| 窗口调整后的布局计算 |   防抖   |    用户停止调整窗口后再计算布局，避免重复渲染    |
|  拖拽元素的坐标更新  |   节流   |        按固定频率更新坐标，避免浏览器卡顿        |

