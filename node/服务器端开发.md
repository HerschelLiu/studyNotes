# 服务器端开发(后台开发)

[TOC]



## node.js概述

它是javascript的一个运行环境（runtime），是用JS语言去做后台开发。

Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。

Node.js是一个事件驱动I/O服务端JavaScript环境。实际上它是对Google的V8引擎（由C++语言编写的一个JS引擎）进行了封装，V8引擎执行Javascript的速度非常快，性能非常好。

### node.js的好处

1. 性能高是PHP语言的86倍。

2. 和前端配合较为方便。

3. 节省开发成本。

     Node.js让javaScript流畅的运行在服务器端，打破了前后端语言边界，解放了前端程序员的职责约    束，走向一个崭新的舞台。

     可以解析JS代码（没有浏览器安全限制），还提供了一系列API，例如：文件的读写fs，进程的管理，网络通信等。

4. 异步I/O：提升总体的并行处理能力，达到充分利用CPU（处理器）的效果。

   i => input => 输入

   o => output => 输出

5. 事件与回调函数

   Node.js 异步编程的直接体现就是回调，Node 所有 API 都支持回调函数，在执行代码时没有阻塞或等待文件 I/O 操作。这大大提高了 Node.js 的性能，可以处理大量的并发请求。

6. 单线程：就是一件事一件事的完成。

7. 跨平台：Node.js 是跨平台的，也就是说它能运行在 Windows、OSX（苹果） 和 Linux 平台上。

### Window 上安装Node.js：

1. 首先安装的路径中不能存在中文。（默认本地安装C盘）

2. 根据电脑的系统安装32/64位的安装包。后缀为.msi。

重点：

★★★测试是否安装成功：

方法一：（1）找到安装目录，在空白处点击shift同时点击右键，打开命令窗口，输入 node -v检测node的版本号，此处的v全称version（版本） 。如果打印出就代表安装成功。

方法二：在开始菜单，运行的地方输入cmd.exe 终端（也就是小黑板）也可以。

方法三：在vscode编辑器中直接点击在终端打开也可以查看。

★★★★★★配置node的全局：作用：能在整个电脑的任意盘符打开node.js。

检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入"cmd" => 输入命令"path"，输出如下结果：

PATH=C:\oraclexe\app\oracle\product\10.2.0\server\bin;C:\Windows\system32; C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\; c:\python32\python;C:\MinGW\bin;C:\Program Files\GTK2-Runtime\lib; C:\Program Files\MySQL\MySQL Server 5.5\bin;C:\Program Files\nodejs\; C:\Users\rg\AppData\Roaming\npm

我们可以看到环境变量中已经包含了C:\Program Files\nodejs\  ,也就可以在任意的地方打开node.js.（一般安装时候会默认，如果提示错误，就需要手动去匹配node的全局，把安装的绝对路径放在path中，步骤：a：点击计算机右击属性→高级系统设置→高级→环境变量→PATH→将node.exe应用程序所在的绝对路径，添加到PATH的变量中即可。）

### Node.js运行的方法：

1. node.js它只是javascript的一个运行环境，所以在终端输入js代码的时候要先输入node命令，空格，再输入js语法。而在node.exe中的小黑板上输入时，就可以直接输js代码。注意二者的区别。

2. 外部文件，在终端输入大量的js代码不是很方便，我们可以通过外部文件来执行js代码。在js文件的同级目录下，找空白处，按shift点击空白处，打开终端，输入node命令，空格，js文件名称。文件的路径可以是相对路径也可以是绝对路径，同时，后缀名称也是可有可无。

3. VSCode编辑器，直接右击在终端中打开。

### Node.js和HTML.js的区别：客户端js和服务器端js区别

node.js也就是用javascript的语言去做类似于php java的活。

| html.js | 客户端JS     | 浏览器运行          | 操作DOM                |
| ------- | ------------ | ------------------- | ---------------------- |
| node.js | 服务器端的JS | 终端运行（cmd.exe） | 操作文件、进程、服务器 |

### Node.js中的操作按键：npm常用命令

npm是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题。随后详细解答。

1. ctrl+c表示终止当前的进程。

2. 复制的方法：右键点击标记，选中你需要的内容，按回车，到需要的地方，右键点击粘贴。

3. 上下的方向按键可以选择上翻和下翻输入的内容

4. （1）：cd\ 退出根目录。（2）：cd..返回上一级目录。（3）：cd 文件目录  进入文件目录

5. 进去磁盘  直接盘符名称加冒号，如d:，就进入了D盘（不区分大小写）

6. 退出终端 exit。（直接关闭小黑板）

7. 清空小黑板的屏幕 cls  它是一个命令  直接输入。

8. 查看文件内容 type 文件名称.js/.css/.html  不同的文件都可查看文件内部的内容（只能查看内容）

9. 运行js文件  node 文件名称.js （直接是结果）

10. 新建文件夹  mkdir 文件夹名称   （会直接创建文件夹）

## CommonJS的概述：它是node.js的规范

node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。



它的原理：是一个匿名的自执行函数

(function (require, exports, module) {

​    var a = 'a';

​    //所有变量都包在匿名函数里，所以不会污染全局变量

})();

★★★★★需要掌握：1.require（命令）       

2.exports （输出）    

3.module（模块）       



CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。



require方法用于加载模块，读取并执行一个JS文件。这个方法的返回值是是当前模块的module.exports的属性值，该属性的属性值默认值（初始值）为一个空对象。



例如：在demo1.js文件里面写

var x = 5; var addX = function (value) {   return value + x; }; module.exports.x = x; module.exports.addX = addX;

 

//上面代码通过module.exports输出变量x和函数addX。



在demo2.js文件里面写

var a = require('./demo1.js');  console.log(a.x); // 5 console.log(a.addX(1)); // 6 

//可以在终端中运行demo2.js



★★★★★★★module.exports和exports的区别：

module.exports抛出的是当前内容形式（如字符串，函数，数字，布尔值等），而exports只能抛出对象

// 原因：当调用require方法加载模块的时候，实则加载的是当前模块的module.exports的属性值，而exports相对于是module.exports的一个变量，如果直接重新赋值，相当于切断了两者之间的联系，此时exports不再指向module.exports，而require这个方法加载的是module.exports的属性值，所以require方法的返回值会变成空对象(空对象是module.exports的初始值)。如果你觉得，exports与module.exports之间的区别很难分清，一个简单的处理方法，就是放弃使用exports，只使用module.exports。



总结就是：

1. require-> 加载模块

2. module.exports -> 对外抛出

3. exports是module.exports的一个变量。

### CommonJS模块的特点如下

1. 所有代码都运行在模块作用域，不会污染全局作用域。

2. 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。

3. 模块加载的顺序，按照其在代码中出现的顺序。

### 主文件和子文件的区别

1. 主文件，同种用main.js来命名，它是里面有require，它的主要作用是用来引入子文件的。

2. 子文件，也叫子模块，它是不能独立的运行的，它是用于抛出的，最好不要在子文件中有打印的操作。

## require命令的路径

首先require用来加载其它模块（也就是子模块）的命令，读入并执行一个javascript文件，如果没有发现指定模块，会报错。如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后缀，再去搜索。所有后缀是可填写也可以不填写的。根据参数的不同格式，require命令去不同路径寻找模块文件。



1. 以 " / " 开头，表示绝对路径，指向当前磁盘的路径，找当前主文件所在的磁盘中查找指定的子文件。

2. 以 " ./ " 开头，表示相对路径，跟当前主文件的位置相比，同级目录下的子文件。

3. 如果不以 " / " 或 " ./ " 开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（也就是第三方包，就是别人封装好并发布的官网的包，全局安装或局部安装）。所以在引用子文件的时候，一定要加路径指向。

## module对象

Node内部提供一个Module构建函数。所有模块都是Module的实例。例如：

```javascript
function Module( ){

  this.exports={ };

}

var module=new Module( );

console.log(moudule.exports);  

```





我们我要创建的子文件就需要挂载在module.exports上。在通过主文件的requite就可以引用出来。



★★★ 每一个模块内部，都有一个module对象，代表当前模块，它具有以下的属性 :

1. module.id 模块的识别符，通常是带有绝对路径的模块文件名。（凡是只有一个点的通常为主文件）

2. module.filename 模块的文件名，带有绝对路径。

3. module.loaded 返回一个布尔值，表示模块是否已经完成加载。

4. module.parent 返回一个对象或者null，表示调用该模块的模块。如果是主模块（主文件，返回的是null）;

5. module.children 返回一个数组，表示该模块要用到的其他模块。（也就是子模块）

6. module.exports 表示模块对外输出的值。



★★★ exports变量

为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。var exports = module.exports; 可以直接在exports上挂载对象，但是要注意exports和module exports的区别（笔记上面有写）。

## 模块的缓存

第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性。模块可以加载多次，但是只会在第一次加载的时候运行一次，然后运行结果就被缓存起来，以后再加载，就直接读取缓存的结果。所以，要想让模块再次运行，必须清除缓存。



所有缓存的模块保存在require.cache之中，如果想删除模块的缓存，可以像下面这样写。

1.删除指定模块的缓存 delete require.cache[模块的名字];  2.删除所有模块的缓存 方法一：Object.keys(require.cache).forEach(function(ele) {   delete require.cache[ele]; });

方法二：for(var  i  in  require.cache){

delete require.cache[ i ]

};//用for..in..的方法。 

注意，缓存是根据绝对路径识别模块的，如果同样的模块名，但是保存在不同的路径，require命令还是会重新加载该模块。

## 内置模块

内置模块，就是安装node成功后自带的,存于本地安装目录的模块。是自带的不可以随意的修改。

使用方法：通过require引入,然后使用就可以。

例如：fs是操作文件的、http是操作服务的、path,url,querystring是操作路径

## 第三方包

第三方包（就是别人上传的包，需要到官网下载后才可使用，例如Jquery,zepto等，还包括自定义的）

使用方法：第一步要先进行下载([www.npmjs.com)](http://www.npmjs.com))，第二步通过require引入，第三步再去使用。

  小补充：下载好之后，第三方包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过    

  require('包名') 的方式就好，无需指定第三方包路径。  

  例如var express = require( ' jquery ');     



★★使用第三方包前提是必须满足两个条件：

1.  必须存放于node_modules目录里     
2. 第三方包必须是一个文件夹，不能是一个文件

★★★★如何下载第三方包：首先第三方包位于([www.npmjs.com)](http://www.npmjs.com)) 这个官网里面。

### npm命令

NPM 是强大的包（第三方包）管理工具，主要用于包的上传、下载、卸载等。

NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：

（1）允许用户从NPM服务器下载别人编写的第三方包到本地使用。

（2）允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。

（3）允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。可以通过输入 "npm -v" 来测试是否成功安装。出现版本号提示表示安装成功。



### package. json文件

概念：每个项目的根目录下面，一般都有一个package.json文件，它是包的管理文件，（包含了包的名称和包的版本号，包的描述，以及一些包的依赖等配置信息）。如果想自定义入口模块的文件名和存放位置，这个文件是可以根据需要来进行修改的。

生成这个文件的方法：小黑板里面输入npm init  （然后一路回车，执行的都是默认的参数，也可修改其中的参数，如名字，版本号等都可以修改。）



package.json文件就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。

例如：下面是一个最简单的package.json文件。

```json
{

  "name": "d2.class",   //包名称（项目名称）

  "version": "1.0.0",     // 版本号

  "description": "",       //包的描述（就是解释这个包是干嘛的）

  "main": "main.js",    //主入口文件  

  "scripts": {   //封装了一些命令指令，指令与指令之间用逗号隔开

    "test": "echo "Error: no test specified" && exit 1"，

     "test": "echo "Error: no test specified" && exit 1"

  },

  "author": "",

  "license": "ISC"

}

```





★★★★★其中scripts字段：用于封装一些命令行的指令（运行脚本命令的npm命令行缩写）。

（1）.自带的指令

指令名称 : '指令'  

例如：“ start ”: " node main.js " （执行main.js这个文件）。

（start就是指令名，后面跟的就是要做什么事儿）；

就通过package.json写好指令start，再在小黑中写 npm strat，就可以运行了。

（2）.自定义的指令

自定义指令名: '指令1 & 指令2' （可以写多个指令，中间用&隔开）

例如：“build” : " npm init "  (build就是自定义的指令名称，要做的事情就是创建一个package.json文件)。

但是自定义的指令是不能直接npm 指令名去运行的，必须在小黑板中输入npm run 自定义指令名。



★★★★★其中main字段:指定了加载的入口文件，当没有这个字段的时候，这个字段的默认值是模块根目录下面的index.js。也就是说没有main字段的时候，就一定文件中就一定有一个名称为index.js的文件。

### node_modules文件夹：它是在下载第三方包时自动生成。

用于存放下载好的第三方包

### 下载第三方包：

首先要注意 ，必须有一个package.json文件，如果没有下载的包就会乱跑。所有要先创建package.json文件。创建方法看上面。

下载方法一：.在小黑板中输入：npm  install  需要下载的包的名称（以下简称包名）

​                      npm  install  包名  （但是这种方法不常用，一般后面都会更参数）



下载方法二：npm  install  包名  --save 

这种方法会在package.json中生成一个dependencies（依赖）  （打包上线的的放这）



下载方法三：npm  install 包名  --save-dev

这种方法会在package.json中生成一个devDependencies（依赖）（本地开发环境的放这）



下载方法四：npm install 包名 -D

D是--save-dev的简写  （会替换devDependencies，但是里面的包会增加，不会覆盖）



★★★★★下载方法五：npm install 包名  -g       （配置环境变量）

global的简写 全局安装   （输入参数-g就是把第三方包下载到了全局，而要查看npm的全局路径，可以通过在小黑板输入npm root -g，就可以查看到全局的路径，就可找到包下载的位置node_modules文件夹里）

​    下载到本地只可以本地使用，但是下载到全局，就是各个模块都可以使用        

！！！！但是：加-g参数只能保证我把包下载到npm root -g这条命令返回的路径里，并不能保证包可以全局被访问到，要想全局被访问到，必须配置NODE_PATH环境变量。

NODE_PATH配置方法：打开计算机右键属性 → 高级系统设置 → 高级 → 环境变量 → 系统变量->新建 → 变量名必须为NODE_PATH → 变量值设置成包所在的全局路径（换言之，就是设置成npm root -g 的返回值即可）。



全局默认的路径是C盘，同时，我们也可以更改npm全局路径：方法如下

方式 1、通过命令的形式去进行更改 （必须先更改缓存在更改目录，并且地址要一致）

（1）更改缓存npm config set cache "路径" （注意路径中不带node_modules）

（2）更改路径npm config set prefix "路径"

方式 2、直接找到.npmrc文件进行修改 通过npm config ls (查看npm默认配置)命令可以找到.npmrc文件的存放位置



★★★★★下载方法六：批量下载

（1）npm init 生成package.json 文件

（2）在package.json中手动添加dependencies / devDependencies 

（3）devDependencies: {

​            " 包名1" :  " *  " ,

​             " 包名2 " :  " *  " ,

​                 .....

​               }

​          注：*代表当前包的最新版本（就是在不知道版本号的时候）

 

当通过 npm  install  包名，下载包的时候会自动检索本地有没有package.json文件和node_modules文件夹

★当两者都没有的时候，会默认向上逐级查找，一直到找到为止，把下载包放入node_modules里面。

★★当有package.json，没有node_modules文件夹的时候，不会向上查找，会在当前目录，自动生成一个node_modules文件夹，然后将下载的包放进去。

★★★当有node_modules文件夹，没有package.json文件的时候，会把下载的包放到当前的node_modules里。

### 第三方包的加载规则：

当调用require()方法加载第三方包的时，会以当前执行的主文件所在的目录作为根目录逐级向上查找所引的第三方包，但是不会向下查找，只会向上级查找，直到找到第三方包，如果一直查找到盘符的跟路径都没有找到第三方包的话，则会去全局（C盘）路径下找第三方包，找到则加载成功，找不到的话就会报错。

### 如何将自己建立的第三方包上传到官网

首先必须满足3个条件：

1. 首先上传的必须是一个文件夹。

2. 上传的文件夹必须放在node_modules文件下。

3. 必须配置入口文件。配置入口文件的方法

（1）：必须将主文件的文件名称设置为index.js。同时，必须含有package.json文件。

（2）：可以不必更改文件名称，但是必须配置package.json文件，就是先要生成一个package.json文件。（里面有主入口文件的字段main）

4. 必须含有package.json文件。

5. 发布到官网的地址：

（1）www.npmjs.com。（要注册一个自己帐号）

（2）找到你要发的包的内部打开小黑板，输入命令 npm adduser

​         然后填写登陆名称和密码（密码是不显示的）

（3）在输入发布代码npm publish

需要注意的是：（1）发布的包中必须含有package.json文件

（2）package.json文件中必备两个字段：name和version（名称和版本号）

（3）发布的包的名字不能与npm官网现有的包重名，一定要记住 修改名字的时候，package.json里面的名称也需要修改。

### 卸载第三方包

1. 本地卸载  小黑板中输入命令   npm uninstall 包名（要卸载的包的名称）

2. 官网卸载  小黑板中输入命令   npm unpublish 包名 @版本号

注：（1）官网规定  发布时间超出24个小时的包将无法卸载。

（2）如果卸载了发布过的包，修改过的内容之后再次上传的时候，需要修改版本号在进行发布。

## 命令行程序

是一个以.cmd为后缀名的应用程序

1、新建一个以.cmd为后缀名的文件

2、在文件中输入命令，并且以 %* 结尾

3、输入@pause 防止程序运行完毕之后自动退出终端

4、双击运行

## 内置模块 —— fs 模块   操作磁盘中文件或文件夹的内置模块

`var path = require("fs");`

fs是filesystem的缩写，该模块提供本地文件的读写能力，它是node.js中操作磁盘文件的内置模块。（它只能操作文件和文件夹），这个模块中每一个方法都对应的有异步和同步两种操作形式。同步方法都以Sync结尾，异步方法都支持指定的回调函数。注意：fs里的每一个异步函数都没有返回值，所以当需要返回值的时候肯定是同步操作，不需要返回值的时候是异步操作。

### 读取文件 （只能操作文件）

fs.readFile( )异步操作，fs.readFileSync( )同步操作

（1）异步操作：语法：fs.readFile(要读取的文件，对象或者字符串，function（err,data）{ }）

★ 这个方法的第一个参数是要读取文件的路径，可以是绝对路径，也可以是相对路径。注意，如果是相对路径，是相对于当前进程所在的路径，而不是相对于当前脚本所在的路径。

★ 方法的二个参数是可选的指定读取的时候用什么编码格式，可以是一个对象也可以是字符串。例如设置成对象：{encoding：" utf-8 " },就是编码格式为utf-8,也就是字符串格式。 也可以直接设置成字符串“utf-8”。如果不填写这个参数，它的默认值是null；

★ 方法的第三个参数是读取完成后的回调函数。该函数的第一个参数err是发生错误时的错误对象，当读取成功的时候返回的是null，当失败的时候返回的是错误对象，所以一般都要对它进行判断，如：if(err){ throw err }。也就是说当err为真的时候也就是有错误的时候，要将错误抛出，让程序员知道到底是哪里出错了，一目了然。或者可以打印错误对象if(err){  console.error(err);   return}，但是这个打印之后还会执行后续的操作，所以一定要用returne掉。不做下一步的操作。第二个参数data是代表文件内容，当读取成功的时候，返回的是（Buffer格式的）文件里面的内容，但是可以通过toString( )的方法转为字符串，也可以设置这个方法的第二个参数读取文件的格式。读取失败的时候返回的是undefined。

（2）同步操作：语法：fs.readFileSync( 要读取的文件，对象或者字符串）；第二个参数也是可以选的。但是同步的方法没有回调函数，所以同步方法的返回值就是读取到的结果，我们经常创建一个变量接收它。例:var data=fs.readFileSync("./a.js","utf-8")；

异步操作是可以同时执行多个事情。而同步操作是按部就班，按顺序执行。

### 写入文件 （只能操作文件）注：如果要写入的文件不存在，则会创建文件，如果文件存在，则会替换里面的内容。

 fs.writeFile( )异步操作，fs.writeFileSync( )同步操作

（1）异步操作：语法：fs.writeFile(" 要写入的文件的地址 "，写入的内容，function（err）{ }）

这个方法的第一参数的要写入文件的地址，就是代表你要给谁写内容，第二参数为要写入的内容，第三个参数为可选，也是设置读取的格式编码，默认是utf-8，第四个参数是一个回调函数，他只有一个参数err错误对象。(注意：一定要有第二参数，如果没有会变成后面的参数，或者啥都没有undefined )

（2）同步操作：语法：fs.writeFileSync(" 文件地址 " , " 写如的内容"）

  小补充：实现拷贝文件，先要读取要复制的文件内容，在将内容写入新的文件中，实现拷贝。  

### 向文件中追加内容（不想要替换原始的内容，只是追加新的内容的时候的方法）

 fs.appendFile( )异步操作，fs.appendFileSync( )同步操作

（1）异步操作：语法：fs.appendFile（" 文件 "，" 要追加的内容 "，function(err) { }）;

（2）同步操作：语法：fs.appendFileSync（" 文件 "，" 要追加的内容 "）;

### 读取文件夹（也叫文件目录）（只能操作文件夹）

fs.readdir( )异步操作，fs.readdirSync( )同步操作

（1）异步操作：语法：fs.readdir（“文件夹”，function(err,paths){ }）;

一个参数为要读取的文件夹地址名称，第二个参数是一个回调函数，这个回调函数有两个参数，第一个参数err是发生错误时的错误对象，第二个参数paths的值是一个数组（这个数组包含文件夹里面的所有文件，形成了一个数组格式）。

（2）同步操作：语法：fs.readdirSync（“文件夹”）;  （同步操作没有回调，所以这个方法的返回值就是一个paths数组，记住要var 一个变量接收）

### 创建文件夹（也叫文件目录）（只能操作文件夹）

注：当要创建的文件夹已经存在了，就或抛错file already exists，文件夹已经存在。就是不可以放两个同名的文件夹。

（1）异步操作：语法：fs.mkdir（“要创建的文件夹名”，function(err){ }）;

（2）同步操作：语法：fs.mkdirSync(“要创建的文件夹名”)；

### 删除空文件夹（只能操作文件夹）

（1）异步操作：语法：fs.rmdir（“要删除的文件夹名”，function(err){ }）;

（2）同步操作：语法：fs.remdirSync(“要删除的文件夹名”)；

### 判断文件 / 文件夹 是否存在（能操作文件夹或文件）

（1）异步操作：语法：fs.exists（“文件或文件夹”，function（exist）{ }）;

回调函数中的参数exist，它的返回值是一个布尔值，如果文件或文件夹存在则返回true,不存在返回false。

（2）同步操作：语法：fs.existsSync（“文件或者文件夹”）;

### 查看文件 / 文件夹的信息（能操作文件夹或文件）

（1）异步操作：语法：fs.stat（“文件或文件夹”，function（err,st）{ }）;

回调函数中的第一参数err是发生错误时的错误对象,第二参数st它的返回值是一个对象，包含了文件或文件夹的一些信息（其中我们长关注的是size，文件的大小还有以下文件时间状态的一些信息：

atime是指access time，即文件被读取或者执行的时间

ctime即change time文件状态改变时间

mtime即modify time，指文件内容被修改的时间。

birthtime 文件被创建的时间）。

补充：st.isFile( )方法用来判断是否为文件，st.isDirectory方法用来判断是否为文件夹。两个方法的返回值都是布尔值

（2）同步操作：语法：fs.statSync（“文件或者文件夹”）;

### 给文件 / 文件夹重命名（能操作文件夹或文件）

  (1）异步操作：语法：fs.rename（“要修改的文件或文件夹”，新的文件名，function（err）{ }）;

（2）同步操作：语法：fs.renameSync（“要修改的文件或文件夹”，新的文件名）;

### 小文件拷贝的原理

首先读取文件，是先将文件的内容拷贝到电脑的某个内存中，当内容全部读取完毕的时候，会促发回调函数，回调函数中的data参数就是读取到的内容，同是在回调函数中调用写入文件fs.writeFlie（）的时候会先自动生成一个容器，并将内存中的东西在放到新设定的容器当中。

这种方法只适用于小文件的情况，因为内存的容量是有限制的，当文件过大的时候，会容易报错，造成内容爆仓。

1.先要读取文件，利用 fs.readFile( )异步操作，fs.readFileSync( )同步操作，回调函数的触发时间，是在当文件的内容读取到的时候，才触发回调函数。

2.然后写入文件，利用 fs.writeFile( )异步操作，fs.writeFileSync( )同步操作

### 大文件拷贝的原理

它的实现原理是因为文件过大，所以采用，读取一点内容，就写入一点内容，直到内容完毕。也就是流的概念，而fs.readFile的方法就不适用于大文件的操作，容易内存爆仓，终端就会报错。对于大文件的拷贝，我们只能以流的形式来实现。

数据流的概念：

流是node.js中一个非常重要的概念，也是node.js之所以适用于I/O密集场景的重要原因之一。流是node.js移动数据的方式，代表数据流动方向，流可以是可读的也是可写的（向内流（可读流），向外流（可写流））。在node.js中很多模块都使用到了流。包括HTTP和FS模块。流是以快为单位发送数据，通过监听‘data’事件，每一次得到一块数据即进行一次操作，当数据结束时，监听end事件，执行后续操作。



由于数据是流，这就意味着在完成文件读取之前，从收到最初几个字节开始，就可以对数据有写入的动作。

#### 大文件的读写方法（一）复杂版本：    

1. 可读取的流：

语法：fs.ReadStream（）；当调用这个方法的时候，就开始读取文件，并保存到内存中，而内存中监听到有内容存入，就触发事件。

例如： var readStream=fs.ReadStream（"./a.mp4"）

2. 可书写的流：

语法：fs.WriteStream（）；当调用这个方法的时候，就行程了一个新的容器，（内容是空的）。要在监听事件中才写入内容。

例如： var readStream=fs.WriteStream（"./b.mp4"）;那么b.mp4就是我新创建的一个空的容器。

3. 监听只读数据流的事件：

语法：readStream.on("data"，function(chunk){ })；回调函数中的chunk参数为每次读取到的文件内容，默认是Buffer格式的。

例如：readStream.on("data"，function(chunk){ 

​            //以流的方式写入内容；监测到一点数据，就在容器中写入一点数据。

​          WriteStream.write（chunk）;

})；

4. 数据读取完毕触发的事件：

当内存中检测不到数据的时候，同是也要让写入数据停止。

语法：readStream.on("close"，function(){ 

​          WriteStream.end( )   //写入数据结束

})；

#### 大文件的读写方法（二）简易封装版本：  

1. 创建一个只读数据流：

var rs = fs.createReadStream( “要读取的文件” ） ;

2. 创建一个只写数据流：

var ws = fs.createWriteStream( “要写入的文件”） ;  //创建一个空的容器，准本存放内容。

3. 管道流输出：管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。

rs.pipe(ws);

注：pipe( )方法的实现原理：

1. var rs = fs.createReadStream( “要读取的文件” ） ;

2. var ws = fs.createWriteStream( “要写入的文件”）  ;

3. rs.on("data"，function(chunk){

原理是：读一段，暂停写一段，再读，在暂停写。

​          ws.write(chunk);  //写入文件的返回值是布尔值，没有写完的时候返回false，写完的情况下是true。所以要对这个进行判断。

​          if(！ ws.write(chunk)){   // 当返回值为false的时候代表还没有写完，就需要暂定读取文件等一下。先写在读，在暂停，在写，循环直到读完。

rs.pause( );   // 暂停只读数据流

​            }

 })；

4. ws.on("drain"，function（）｛   //只写数据流结束，但是结束不代表是所有的内容都写完毕了，而是指读取到的那么一小点，写完了。

 //drain事件，用来判断什么时候只写数据流已经将缓存中的数据写入目标中，可以传入下一个待写的数据。

​         rs.resume( ); //只读数据流循环读取

 })；

5. s.on("end"，function( ){     //读取数据流结束

​     ws.end( )；

})

## 内置模块 —— path模块   操作磁盘路径内置模块

模块提供了一些用于处理文件路径的小工具，我们可以通过以下方式引入该模块：

var path = require("path")；

### 格式化路径的方法：用于规范化路径，当路径写错的时候，可用此方法修正错误的路径。（方法）

path.normalize(p)：

例如：var path = require("path");

var add = "E:\node.home///D5.class";  //此处的路径是错误的，路径有多个//

var p = path.normalize(add);

console.log(p);//通过path,路径会被规范修改成正确的路径。

### 提供特定系统平台的路径分隔符，返回的是一个字符串。（属性）

path.delimiter 

（1） Windows系统中多个路径用分号（；）隔开。

（2） Linux 系统中多个路径用冒号（：）隔开。

###　获取文件后缀名。如果一个路径中并不包含'.'或该路径只包含一个'.' 或这个'.'为路径的第一个字符，则此命令返回空字符串。（方法）

path.extname(p) 

（1）当访问的文件含有多个点的时候，读取的是最后一个点后面的后缀内容。

例如：console.log(path.extname('index.ss.md'))；那么它返回的是最后一个 .md。

（2）当访问的文件最后是以一个点为结束的时候，读取的就是这个点。

例如：console.log(path.extname('index.'))； 那么它返回的是一个 . 。

（3）当访问的文件最后是以一个点开头的话，读取的就是一个空字符串。

例如：console.log(path.extname('.js'))； 那么它返回的是一个“ ”。

（4）当访问的文件只有一个点的时候，读取的就是一个空字符串。

例如：console.log(path.extname('.'))； 那么它返回的是一个“ ”。

（5）当访问的文件没有后缀名称，也就是没有点的时候，读取的就是一个空字符串。

例如：console.log(path.extname('index'))；那么它返回的是一个“ ”。

### 使用平台特定的分隔符将所有给定的段连接在一起，然后对结果路径进行规范化。也叫追加路径。（方法）

path.join("参数一"，"参数二"，"参数三"....)

此方法的参数可以不填，也可以填写多个（就是0-多个参数）。用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，它的返回值是一个相对路径。当要返回绝对路径的时候，要在第一个参数传指定的盘符。（也就是看你自己想要啥路径。然后就根据情况传参）。不同的系统分隔符不同Unix系统是"/"，Windows系统是"\"。

### 返回路径中代表文件夹的部分 。（方法）

path.dirname(p)

此方法中认为的文件夹，是以最后一个斜杠/来划分的前半部分，也就说当我的路径为path.dirname('C://src/lib')，它只会返回src,虽然lib也是一个文件夹，但是它会以最后一个斜杠为划分点。

### 返回路径的最后一部分。（方法）

path.basename(path ,ext)        参数ext代表文件扩展名，此参数可以选填。

此方法是以最后一个斜杠作为划分点，返回最后一个斜杠后面的内容，例如：path.basename('src/lib/a.js')，那么它返回的就是a.js。而第二个参数是可选择填写，它是一个扩展名，当填写此参数的时候，返回的就不在是a.js，而是a,它会把文件的后缀名称去掉。当然，后缀名称必须与实际的名称一致才可以去掉，不一样的话，还是会返回a.js。

### 将一系列路径或路径段解析为绝对路径。(方法用于将相对路径转为绝对路径）。（方法）

path.resolve("参数一"，"参数二"，"参数三"....)

此方法可以接受0到多个参数，当不传参数的时候，此方法返回当前执行文件的绝对路径。

当有参数的时候（参数依次表示所要进入的路径），但是给定的参数是个相对路径，并不能生成绝对路径的时候，系统会自动将其放在当前执行文件的绝对路径目录下。

还要注意的是路径是把参数从右向左进行追加，直到找到绝对路径，则停止追加。例如console.log(path.resolve('src', '/lib', 'a.js')); 从右向左，但是当第二个参数/lib的时候就是一个绝对路径，所以将不再追加src。

### 判断参数 path 是否是绝对路径。（方法）

path.isAbsolute(p);

此方法的返回值是布尔值。要注意的是当你传入的路径是不标准化的路径的时候，此方法会自动变为标准的路径后，在进行判断。

### 用于将相对路径转为绝对路径，返回的是相对路径。（方法）

path.relative(from, to)

此方法接受两个参数，from表示当前所在的位置，to代表想要到达的位置。这两个参数都应该是绝对路径。该方法返回第二个路径相对于第一个路径的那个相对路径。

例如：path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb') 它的返回值是：'../../impl/bbb' 

上面代码中，如果当前目录是/data/orandea/test/aaa，进入path.relative返回的相对路径，就会到达/data/orandea/impl/bbb。

如果path.relative方法的两个参数相同，则返回一个空字符串。

### 路径转对象。（方法）

path.parse(address);

例如：var address = 'C://src/lib/a.js';

var obj = path.parse(address);

### 将路径转为对象后在转成字符串。（方法）

path.format()

例如：var address = 'C://src/lib/a.js';

var obj = path.parse(address);

console.log(path.format(obj));

但是这个方法要注意几点：

（1）.如果转成的对象中提供了dir，root路径将被忽略。例如：

var str = path.format({

​              root: '/lib',

​              dir: '/home/user/dir',

​               base: 'file.txt'

 });  那么打印str的结果将不包含 '/lib'。也就是说不再读取root的路径。



（2）如果转成的对象中提供了base，那么ext和name将被忽略

var str = path.format({

​              root: '/',

​              base: 'file',

​              ext: '.html'

});

### 返回绝对路径的方法：

1. path.resolve()方法返回绝对路径。当不传参数的时候，此方法返回当前执行文件的绝对路径。

2. process.cwd()方法返回的也是绝对路径。

方法一和方法二都返回当前工作目录的绝对路径。（工作目录就是当前执行文件的）

3. __dirname，它是一个全局的变量。在任何模块文件内部，可以使用__dirname变量获取当前模块文件所在目录的完整绝对路径。

方法三返回的绝对路径，是它所在的文件的绝对路径。它会随着文件位置的改变而改变。

4. __filename，它返回的路径可以精确到文件。  但是不常使用。

## 全局对象Buffer

在node.js里面提供了Buffer类处理二进制的数据。并且在node.js里面有些重要的模块例如fs，http中的数据传输以及处理都有Buffer的身影，因为一些基础的核心模块都要依赖Buffer，所以在node启动的时候，就已经加载了Buffer，我们可以在全局下面直接使用Buffer。它代表一个缓冲区，存储二进制数据，是字节流，网络传输的时候，就传输的是这样的字节流。在写文件的时候，也使用的字节流。

创建Buffer的方法：

1. new Buffer (size) 创建一个指定大小的Buffer。参数size为数字类型，是指定多少个字节的意思。

2. new Buffer（str）根据传入的字节创建buffer。参数str是你传入的字符串，然后通过new Buffer转为buffer格式。（常用）

3. 使用Buffer.from（str）接口去创建Buffer对象，用于申请内存，并将内容写入刚刚申请的内存中。（用法同上）

buffer.lenth属性：用来查看buffer的长度。

写入buffer的方法：先创建buffer的实例，在通过实例的write方法写。

语法：var buf=new Buffer(10) ; 

buf.write(str，offset，length)； 

它可以接收四个参数，第一参数为字符串，表示要写入的内容。第二个参数offset代表偏移量，是指从下标第几个开始写入。例如偏移量设置为2，那么它就是从下标2开始写入内容。第三个参数是length字节数，代表只指定输入的字节长度，例如设置为3，那么在你输入的内容中，只能输入3个字。

要注意的是，buffer在一开始创建的时候，大小就已经被固定，且无法更改。buffer格式转为字符串可以用toString( )方法。

拼接buffer的方法：Buffer.concat（[buf1,buf2 ]），这个方法的参数为一个数组，数组中的每一项就是要拼接的buffer。

## 内置模块 —— http模块   操作服务的内置模块

Node.js 提供了 http 模块，http 模块主要用于搭建 HTTP 服务端和客户端，使用 HTTP 服务器或客户端功能必须调用 http 模块。

首先提供两种使用方式：

（1）作为服务端使用时，创建一个HTTP服务器，监听HTTP客户端请求并返回响应。

（2）作为客户端使用时，发起一个HTTP客户端请求，获取服务端响应。

### 使用Node搭建HTTP服务器：

1.引入模块   

 var http=require("http");       并且把它赋值给http变量。

2.搭建http服务器（也叫创建服务）

http.createServer(function (request, response) {



​    if (request.url.indexOf('favicon.ico') !== -1) {  //     / favicon.ico 是网站图标的默认请求  这个为补充。

​        return;  //阻止代码的产生。不需要发起这个请求。

​    }

​    response.writeHead(200, {'Content-Type': 'text/html'});

​    response.write(" Hello World ");

​    response.end();

}).listen(8080,function( ){ });



写法的分析：

1. 调用http模块的createServer方法，创造一个服务器实例。

2. ceateServer方法接受一个回调函数作为参数，此回调函数的触发时机是在客户端发送请求的时候触发。同时，这个函数的触发次数跟客户端的请求次数有关系。

当在终端执行当前文件的时候，只是调用了require引用，creadServer创建，listen监听，这三个方法，而里面的回调函数并没有触发，它的触发是在客户端发送请求的时候在触发。（也就是在网页中输入网址的时候才触发。浏览器相当于客户端）

3. 该函数的request参数是一个请求体对象，表示客户端的HTTP请求，它具有以下属性：

（1）request . url：发出请求的网址（路径）。（注，它的开头必须是 “/ ”，就是端口号后面的内容，例如 /index.html）

  补充：当你发起请求的时候，会执行两次，第一次执行的是您输入的请求路径，而第二次的请求原因是因为会自带一个浏览器网站图标的默认请求，   

  favicon.ico。所以一般情况下我们要把这种请求return掉。不让它发起这个请求。

（2）request . method：HTTP请求的方式。  它的属性值都是大写的POST和GET。

（注：凡是操作路径的就GET）而什么时候是post是在发送ajax的时候将方式更改为post。也可以在验证表单的时候将method的方式更改为post。要记住存在跨域的问题，ajax是不能够跨域，form表单是可以跨域的。（当协议和域名、端口不相同的时候，就存在跨域）

  补充：当在终端打印request的时候，终端的空间有限制，不能把文件的内容打印完整，需

  要在执行终端的时候，在执行的文件后面输入，> server.log命令，它会自动创建一个本地

  的server.log的日志文件。将您的的内容保存于这个日志中。文件的名称server.log这个名字可以随意的更改。

（3）req.setEncoding("utf-8")。将buffer转为字符串。 注意这种方式只有在post方式的时候才有。

4. 该函数的response参数是一个响应体对象，表示服务器端的HTTP响应。

5. response.writeHead方法用来写入HTTP响应的头信息；它接收两个参数，参数一为状态码如：200(表示请求成功），404（表示未找到）等。

参数二是可选填写的参数，它是状态描述，它是一个对象。其中Content-Type规定内容的类型，它的值有：

（1）text/plain   纯文本格式解析，不支持解析html标签，css选择器以及js语法等。

（2）text/html;charset=utf-8   支持解析html标签以及行内样式，设置字符编码可以支持中文。

（3）text/javascript   支持解析js语法

（4）text/css   支持解析css选择器 

（5）image/png 、image/gif...  支持解析相应格式的图片

6. response.write方法用来设置HTTP响应内容。它可以接收两个参数，参数一：只能是一个buffer或者字符串格式的内容，表示发送的内容。第二个参数为可选填写的参数，当第一个参数为字符串的时候，就需要第二个参数来说明它的编码方式，默认是utf-8。

注意：而响应的内容，要根据请求的需求来改变，根据请求，返回响应的相应内容。不能写死。

 补充：Buffer.form("任意字符")， 这个方法可以将参数变为buffer格式。

Buffer.concat( ),这个方法将一组Buffer对象合并为一个Buffer对象。

7. response.end方法用来结束相应。并可以写入HTTP回应的具体内容，要注意的是必须调用这个方法来结束响应，否则客户端将处于挂机状态（就是一直转圈），直到请求超时。

注意：response.write（）这个方法可以用response.end（）这个方法代替。表示结束响应，并且传送响应的内容。

8. 最后的listen 表示启动服务器实例，用于监听端口号 。它可以接收两个参数，第一个参数为端口号，端口号一般为4位数如：8080（注，数字就在3，6，8，9）中挑选使用。但是要注意的是：一台电脑可以搭建多个服务器，但是一个端口只能监听一个服务器 。所以端口号不能重复。第二个参数为可选填写的参数，是一个回调函数。



在设置响应内容的时候，最好要去捕捉同步的异常，能够防止异常导致服务器的挂机，友好的返回用户提示信息告知访问的页面不存在。同时在控制台发送错误的编码。

语法：

try{

异常信息

}catch(e){

//此处可以友好的返回产生错的信息例如：您访问的页面不存在

}

例如：

try{   //捕捉同步的异常信息及错误的

response.writeHead(200,{"Content-Type":"text/html"});

response.write(fs.readFileSync(" "))；

}catch(e){

response.writeHead(404,{"Content-Type":"text/html"});  //在控制台也返回错误的信息代码

response.write("您访问的页面不存在！”）

}

### 客户端发起请求到服务器的发送步骤：

1. 当客户端发送请求时：

1）在地址栏住输入要请求的域名，如www.baidu.com,它会首先在谷歌浏览器中搜索自身的缓存，查看浏览器中是否缓存过该页面，如果有就直接读取，如果没有就会到系统自身去搜索缓存，有就直接读取。如果浏览器和计算机系统都搜索不到，就会带着域名去访问本地的一个hosts文件，这个文件的作用是换算域名的，它将localhost换算成一个IP地址，如过能将域名换算成地址，就返回地址到客户端。如果本地没有查找不到也换算不到就到dns域名解析器。dns将域名转换为IP地址之后返回给客户端，客户端在拿着IP地址想服务器发起请求。

2. 客户端和服务器之间的三次握手

### 客户端与服务器之间的交互：form表单/AJAX

1. 获取get方式提交过来的数据  关键是要看request.url，通过地址栏获取信息。将地址栏的信息通过截取的的方式，获取用户输入的信息。

2. 获取post方式提交过来的数据，此方式的传送的数据量较大，保密性好。不会出现在地址栏中，因此通过request.on（“data”）的监听方式。但是方式可以触发多次，所以不适合将end放在里面，因此我们还需要一个事件request.on（“end”）;

data事件会在数据接收过程中，每收到一段数据就触发一次，接收到的数据被传入回调函数。end事件则是在所有数据接收完成后触发。

request.setEncoding("utf-8")  //这种方式只有在post方式的时候才有。

request.on("data",function(chunk){

//获取到的chunk是一个buffer，可以通过toString()的方式转换为文字，同时也可以用上面setEncoding的方式来设置。

});

### http做为客户端的使用：

作用：可用于向本地或远程的服务器发送跨域请求，去请求数据。

请求本地服务器

1. 引入http 模块

2..request（）方法。方法用于发出HTTP请求  

语法：http.request(服务器地址，function(response){ }); 

request方法的可以有两个参数，第一个参数代表服务器的地址，它可以是一个字符串，也可是一个对象（当在请求一些特别信息的时候可以设置为一个对象去请求）

注：当第一个参数为一个对象的时候，可以设置如下：

var options={

protocol: 'http:',  //http协议可以省略设置。

host："localhost",      //域名  默认值：localhost

port：8080,    ///端口号         默认值：80

path：根据需要请求来设置路径例如：“/src”，  //路径   默认值： "/"根路径

method："get"  //请求方式  默认值：“get”

headers：｛//请求头信息

"Accept-Encoding"："gzip"    //当你需要的是压缩文件的时候，就设置这个它向服务器请求gzip算法压缩过的文件的命令

“Content-Type”：" text/html "   //设置请求内容的格式

//也可以自定义  客户端设置请求头信息，服务器获取请求头信息

｝

｝

第二个参数是一个函数，它的触发时机是当服务器有返回的时候。用来接收服务器的返回值，通过response.on("data",function(chunk){})监听数据响应事件，他的函数是在服务器有返回值的时候才会触发。获取到的chunk是一个buffer，我们可以通过response.setEncoding("utf-8")来将buffser转为字符串，或者toString( );同时当响应的数据过大时候，这个事件也是会触发多次的。所以最好也是申明一个数组或字符串的容器去接收chunk，在通过response.on("end",function(){}）数据接收完毕的时候去合并数组或者字符串，通过Buffer.concat(arr/str)的方法。

4. request（）这个方法一定要调用.end（）方法去结束请求。



关于头信息：

客户端可以设置请求头信息 服务器可以设置响应头信息

客户端

客户端向服务器设置请求头信息，通过设置对象中的headers

客户端获取服务器的响应头信息，通过res.headers

服务器

服务器向客户端设置相应头信息，通过response.writeHead

服务器获取客户端的请求头信息，通过request.headers

 注：http.get( )方式也是用来作为客户端去发送请求，用get方式来发送请求。这个方法可以不使用.end（）方法来结束响应。会自动结束响应。

语法：http.get(服务器地址，function(response){ });

get方法的可以有两个参数，第一个参数代表服务器的地址，它可以是一个字符串，也可是一个对象（当在请求一些特别信息的时候可以设置为一个对象去请求）



请求远程服务器

还是使用http.request(服务器地址，function(response){ });

例如：请求百度的服务器

http.request({

host："www.baidu.com"，

port：80，

path：" / "，

method："get"，



},function(response){

//获取响应值

res.on("data"， function(chunk){  })

}).end

## 内置模块 ——querystring模块   用于实现地址栏url参数字符串和参数对象的互相转换，以及对参数进行解码或编码。

注：此模块只能用于查询参数，也就是后边地址栏参数，前面所有的路径都不能使用。

1. 转对象    querystring.parse(str,separator,eq)

parse这个方法是将一个字符串转为对象。

参数：参数一：str指需要转换的内容。

参数二：separator（分隔符，是一个可选参数）指用于分割str这个字符串的字符或字符串，默认值为"&"。

参数三eq（分配符，是一个可选参数）指用于划分键和值的字符或字符串，默认值为"="。

注：当属性名相同，属性值不相同，也就是拥有多个属性值的时候，会自动将属性值变成一个数组。将属性值存入数组中。

2. 转字符串   querystring.stringify(obj,separator,eq)

stringify这个方法是将一个对象转换字符串，与querystring.parse相对。

参数：参数一：obj指需要转换的对象。

参数二：separator（分隔符，是一个可选参数）用于连接键值对的字符或字符串，默认值为"&"。

参数三：eq（分配符，是一个可选参数）用于连接键和值的字符或字符串，默认值为"="。

3. 编码 querystring.escape(str)

escape可使传入的字符串进行编码，编码是针对符号和汉字，对英文字母无效。

4. 解码 querystring.unescape(str)

unescape方法可将含有%的字符串进行解码

## 内置模块 ——url模块   用于解析和处理URL字符串

注：此模块可以操作整个地址栏的地址，协议，端口等都可以取出。例如

var address="http://localhost:8080/path?name=cy&age=18"; 都可以解析到。

此模块共有三个方法：

1.允许解析url     url.parse(urlString,boolean)

parse这个方法可以将一个url的字符串解析并返回一个url的对象，这个对象中包含：协议，主机名，端口，域名，查询参数search（是问号以及问号的后边部分，例如：?name=cy&age=18），查询参数query（是问号但是不包含问号的后边部分，例如：name=cy&age=18），路径名称pathname不包含查询参数，path包含路径名称和查询参数，href是整个路径等(以上描述的是要主要记住的)。

这个方法接收两个参数，参数一：urlString是传入一个url地址的字符串。

参数二：这个参数是可选参数，传入为一个布尔值，默认是false ，当为true时，返回的url对象中，query的属性就会变为一个对象。

例如：

var obj=url.parse("http://user:pass@host.com:8080/p/a/t/h?query=string#hash");

这个obj的返回值就是： { protocol: 'http:',     //这是协议 slashes: true,        //指是否含有两个斜杠“//” auth: 'user:pass',  //用户名和密码（这个不重要） host: 'host.com:8080',    //主机名 port: '8080',      //端口 hostname: 'host.com',    //域名 hash: '#hash',    //片段标识符，指向HTML页面中某个DOM元素的ID（这个不重要） search: '?query=string',    //包含问号，及之后的查询字符串 query: 'query=string',   //不包含问号，是问号之后的查询字符串 pathname: '/p/a/t/h',     //端口号和问号之间的那部分内容（路径） path: '/p/a/t/h?query=string',   //是指pathname加上search href: 'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'  //值原始的url } 



2.允许生成url   url.format(urlObj)

format这个方法是将传入的url对象编程一个url字符串并返回

参数：urlObj指一个url对象



3.拼接url  url.resolve(from,to)  为url或href插入或替换原有的标签。

resolve这个方法返回一个格式为"from/to"的字符串，在宝宝看来是对传入的两个参数用"/"符号进行拼接，并返回。form指源地址，to指需要添加或替换的标签。

注：1. 如果form参数最后面没有“/”，就代表to的参数是要替换掉fom的最后一部分

例如：url.resolve("http://whitemu.com/one","two"); 返回值：'http://whitemu.com/two' 

\2. 如果form参数最后面有“/”，就代表to的参数是要添加的部分。

例如：url.resolve("http://whitemu.com/one/","two"); 返回值：'http://whitemu.com/one/two'



区别不同模块相同功能的用法，和适用场景。

| 模块        | 转对象            | 转字符串              | 使用场景                                                     |
| ----------- | ----------------- | --------------------- | ------------------------------------------------------------ |
| path        | path.parse        | path.format           | 操作：磁盘路径、获取后缀名、文件名                           |
| url         | url.parse         | url.format            | 操作：地址栏整条地址例如：http://www.baidu.com，常用于获取路径，查询参数，端口，域名等 |
| querystring | querystring.parse | querystring.srtingify | 操作：地址栏中查询参数                                       |
| JSON        | JSON.parse        | JSON.stringify        | 操作JSON数据的                                               |



登录和注册的原理的执行步骤：

前后台的功能：1.前端也就是html页面获取到用户输入的账户名和密码等信息，并传给后台。

2.后台接收前端传入的信息，并添加到数据库中，因为暂时没有没有学习数据库，所以，我们可以暂时建立一个容器用于存放，例如数组、对象等。将接收的信息与数据库的信息进行对比，并像前端返回存入成功或者失败的信息。

3.前端接收后台返回的成功或失败的值，并显示到页面中，用于提示用户是否注册成功。

后台服务器的主要功能：

1.对文件的访问：（判断是否是文件可以查看它的后缀名称）

（1）文件存在的情况，直接展示页面

（2）文件不存在情况，需要友好的像客户端返回不存在的信息

2.对接口的访问（接口就是ajax中的地址url路径，判断是否是接口就是判断它没有后缀名称）

（1）注册 http://localhost:8888/user?action=register& user=zs&pwd=123

（2）登录 <http://localhost:8888/user?action=login&useer=zs&pwd=123>

## 内置模块 ——zlib模块   用于压缩，解压文件的内置模块

1.accept-encoding：gzip     客户端向服务器请求一个gzip算法压缩过的文件

它是在客户端的头部信息中去设置

2.content-encoding:gzip     服务器向客户端响应一个被gzip算法压缩过的文件

它是在服务器设置的头部信息中去设置，在客户端去获取它。利用它的值来做判断，到底是解压还是不解压



服务器压缩，客户端解压

 为了加快传输速度，节省流量，网络传输过程中一般都会采用压缩算法将文件进行压缩再返回给客户端。它包含多种压缩算法格式。我们只学习gzip算法。

var zlib=require（“zlib”）  //引入

一.gzip压缩算法

（1）普通的压缩和解压的方法

压缩异步方法：

语法：zlib.gzip（要压缩的内容，function(err，decoded){  }）

这个方法接收两个参数，第一个参数为要压缩的内容（利用fs模块先要读取内容），第二个为一个回调函数，err是指，当有错误的时候，它就是一个错误的对象，如果没有错误的时候，err就是null。同时当报错的时候，decoded就是一个undefined.。decoded指压缩后的内容，格式为buffer 。

解压异步方法：

语法：zlib.unzip（要解压的内容，function(err，decoded){  }）

这个方法的参数同上。

（2）以流的方式进行压缩和解压的方法

压缩方法：

步骤：1.创建一个只读数据流

var  rs = fs.createReadStream(要读取的文件)

2.创建一个只写数据流

var ws=fs.createWriteStream(要写入的文件)

3.创建一个压缩流

var gzip=zlib.createGzip( );

rs.pipe(gzip).pipe(ws)

解压方法：

步骤：1.创建一个只读数据流

var  rs = fs.createReadStream(要读取的压缩文件)

2.创建一个只写数据流

var ws=fs.createWriteStream(要写入的文件)

3.创建一个解压流

var gunzip=zlib.createGunzip( )；

rs.pipe(gunzip).pipe(ws)；

## 第三方包 ——cheerio 为服务器特别定制的，快速、灵活、jQuery核心的实现，它的作用是将HTML告诉你的服务器，它也叫做抓包工具（http爬虫）就是帮助我们去获取一些dom的内容。

cheerio第三方包：在node服务端，用来解析网页，是jquery的核心，去除了DOM中不一致的地方。先获得网页的源码，再通过cheerio解析，可以迅速提出想要的字段。

使用步骤：

1.先要下载这个第三方包  （1）npm init  生成一个package. json的包管理文件。（2）npm install cheerio --save  下载第三方包

2.引入第三方包：var cheerio=require("cheerio")



这个第三方包具体含有那些方法：（可在百度查看详细的API）

1.cheerio.load（）方法：这个方法用于加载内容

这个方法的参数可以是一个字符串的html标签，它会自动的把这个字符串当成DOM去解析它，并且我们可以var $去接收这个方法的返回值：例如var $= cheerio("<h1>hello</h1>")；这里的$就和jquery里面的一样使用。



process全局对象  主进程

process对象是 Node 的一个全局对象，提供当前 Node 进程的信息。它可以在脚本的任意位置使用，不必通过require命令加载。

属性：

\1. process.pid：返回一个数字，表示当前主进程的进程号。（每次的进程号都不相同）

\2. process.version：返回一个字符串，表示当前使用的 Node 版本，比如v7.10.0。

\3. process.platform：返回一个字符串，表示当前的操作系统，比如window。

\4. process.argv：返回一个数组，由命令行执行脚本时的各个参数组成。数组第一项是node.exe应用程序所在的绝对路径，第二项是当前执行文件所在的绝对路径。（前两项是固定不会改变的）

\5. process.stdout：指向标准输出，该属性返回一个对象，表示标准输出，该对象的write方法等同于console.log，他俩的区别是： console.log 可以换行，而 process.stdout.write()不会换行。可用在标准输出向用户显示内容。

要向让console.log 也不会换行的写法：console.log=function(msg){

process.stdout.write(msg)

}

console.log("你好"）;

consoe.log("成妍"）;

\6. process.stdin：该属性返回一个对象，表示标准输入。

(1)这个属性含有一个事件：process.stdin.on("readable",function( ){ })的事件。readable的意思是可读的。这个事件是监听标准输入的数据流(就是通过这个事件可以监听到在终端输入的内容)。

(2)这个属性还有一个方法process.stdin.setEncoding( “utf-8”)，用来设置读取的文件格式。

(3)这个属性还有一个方法process.stdin.read( ) ，这个方法返回在终端输入的内容

例如：process.stdin.on("readable",function( ){

  var chunk=process.stdin.read( )；

if(chunk!=null){

chunk=chunk.trim( ) //由于换行会产生默认两个空格，所以要去空格。

console.log(chunk)   // 注：当什么都不输入的时候返回的是一个null，当输入了内容的时候返回的是buffer格式的内容，当要转换成文字的时候要先判断内容，是不是为空，不为空的时候在转换。但是当设置了Encoding的字符编码的时候就在不需要转换了。

}

})

(4)这个属性还有一个方法process.stdin.emit( )方法表示派发自定义事件，参数为自定义的事件名。通过这个方法就可以自定一个事件：例如：

process.stdin.emit("bye")  //自定一个叫bye的事件

process.stdin.on("bye",function(){//需要执行的内容})

方法：

1.process.cwd( ) 方法返回当前进程的工作目录，node执行的js文件所在的绝对路径

要区分：（1）__dirname（表示当前文件的绝对路径，会随着文件路径发生改变）。（2）require("path").resolve() 返回当前进程的绝对路径。（3） process.execPath 启动进程的可执行程序的绝对路径，就是node.exe的绝对路径。

2.process.exit( )方法表示退出当前进程，它可以接受一个数值参数，如果参数大于0，表示执行失败；如果等于0表示执行成功。如果没有参数，默认为0。

注意，process.exit()很多时候是不需要的。因为如果没有错误，一旦事件循环之中没有待完成的任务，Node 本来就会退出进程，不需要调用process.exit(0)。这时如果调用了，进程会立刻退出，不管有没有异步任务还在执行，所以不如等 Node 自然退出。另一方面，如果发生错误，Node 往往也会退出进程，也不一定要调用process.exit(1)。

事件：

1.当前进程退出时，会触发exit事件，可以对该事件指定回调函数

process.on("exit",function( ){ }

2.捕获全局异常的事件（监听全局捕捉到的异常），当前进程抛出一个没有被捕捉的错误时，会触发uncaughtException事件。（这个事件的好处是能保证在遇到异常之前的代码都可以正常被执行，关键就是看代码的执行顺序）。这个事件经常用在服务器中，保证服务器的正常运行。

process.on("uncaughtException"，function(err){ })。回调函数中err是一个错误的对象。

3.信号事件，这个事件是在ctrl+c之后触发的。

process.on("SIGINT"，function( ){ })

## 内置模块 —— Child_Process子进程内置模块  它能合理利用多核cpu，实现cpu负载均衡的

首先要知道node是单线程运行的，每次都只能一核去帮助计算机工作。性能低。当同时执行多个文件的时候，其中一个文件发生了错了，接下来的文件将不再运行。所以一条进程干了多件事，它们是会互相影响的。

所以我们就要引入child_process模块用于新建子进程。子进程的运行结果储存在系统缓存之中（最大200KB），等到子进程运行结束以后，主进程再用回调函数读取子进程的运行结果。

使用前，先要引入模块 var childProcess=require("child_process");而这个模块的返回值中含有多个方法。其中创建子进程的方法有；fork、spawn、exec、execFile 四中方法，同时这方法都有对应的都有同步的方法，也就是在后面加sync。（注：fork没有同步方法）

\1. childProcess.fork（）方法： 参数为需要要执行的JS文件。这个方法只能执行文件，还必须是.js文件。当文件执行完毕之后，子进程就会自动的退出。

fork方法直接创建一个子进程，执行Node脚本，如：建立了一个 main.js的文件和a.js的文件，在main.js文件中执行fork这个方法fork('./a.js') ，它是实现原理就是先在主进程中执行main.js在创建一个子进程去执行a.js。所以这个方法的优点是，（1）合理的利用cpu，（2）多个子进程之间互相不受影响。当一个子进程发生错误时，另外的子进程还是可以继续的执行。（3）当子进程发生异常的时候，就会触发on("exit",function(code){ //code=0表示成功，code=1表示失败})事件，并且再次创建子进程去执行发生了错误的文件，就会再次触发on("exit",function(){})事件，只要错误，就触发，就在创建。一直循环，直到文件不再错误为止。为了避免这种无限的循环，我们就要用到递归的方法。例如：

function createFork (file) {

​    // 创建子进程

​    var worker = childProcess.fork(file);

​    // 监听子进程退出事件

​    worker.on('exit', function (code) {

​    // code=0表示成功，code=1表示失败

​        if (code === 1) {

​            createFork(file);  //递归调自身

​        } else {

​            console.log('执行成功!');

​        }

​    });

}

createFork("./a.js");



我们知道 process.pid：返回一个数字，表示当前主进程的进程号。（每次的进程号都不相同），同时子进程也有进程号就是var worker=childProcess.fork（）,我们去调用这个方法的返回值当中的pid，也就是worker.pid，这就是子进程的进程号。并且子进程的进程号也是随机的，每次的进程号都不相同。

当读取多个文件的时候：

建立数组储存要的读取的文件例如：var arr = ['./a.js', './b.js'];然后创建递归函数，在调用函数的时候，先for..each遍历数组，调用递归函数，arr.forEach(function (file) {

​    createFork(file);

});

主进程退出，杀死所有子进程：子进程.kill( )

主进程退出会触发  process.on("exit", function( ){ })事件

## 内置模块 ——cluster多进程（集群）内置模块  它能合理利用多核cpu，处理网络并发请求（同一时间向服务器发送的多个请求），使cpu负载均衡

子进程用于帮助处理向服务器发送的http请求。优点：1.子进程之间不会互相影响   2.效率高   3.服务不会轻易的崩溃

1.引入  var cluster=require("cluster"); 引入的cluster中含有很多的属性和方法。

（1）属性：isWorker 是否是子进程，属性值为布尔值（注意：子进程都是创建出来的）

（2）属性：isMaster:是否是主进程，属性值为布尔值

2.创建子进程的方法：cluster.fork( )，但是在创建子进程的时候需要先判断在创建，因为只有主进程有. fork( ) 创建子进程的方法。子进程的没有这个方法就会报错。 所以在创建的时候要先判断。例如：

if(cluster.isMaster){

//当返回值为true的时候就代表是主进程，就可以创建子进程，每个子进程的进程号是随机的，并且数据不共享

cluster.fork( );

}else if(cluster.isWorker){

//当返回值为true的时候就代表是子进程

}

3.子进程和主进程之间的通讯：

（1）主进程向子进程通讯  .send(obj)通过send方法发送，参数可以是一个对象。

子进程接收使用.on("message",function(msg){ //接收内容}）

（1）子进程向主进程通讯  process.send(obj)通过send方法发送，参数可以是一个对象。

主进程接收使用process.on("message",function(msg){ //接收内容}）

4.主进程监听事件 ，他的触发时机是在子进程起服务的时候，会触发该事件。它用来监听子进程和服务器。

cluster.on("listening",function（worker，address）{})；

这个事件的回调函数中接收两个参数，worker是代表子进程对象，address是一个对象，代表服务器的地址，端口等信息。

## 内置模块 ——os 它是用于操作系统的内置模块（配合多进程cluster使用）

通过os.cpus（）方法，来获取cpu核数，它的返回值是一个数组，是一些相关的cpu信息。可以根据数组的长度来决定创建多少个子进程。

## 第三方包 ——socket.io 它是用于服务器与客户端（浏览器）之间实施双工通讯（也叫实时通讯）的第三方包

就是客户端可以通讯服务器，服务器也可以通讯浏览器

（在搭建的服务器中写的内容）

使用流程：1. npm init 生成一个package. json的包管理文件

2.npm install  socket.io --save  下载第三方包

3.引入var socketIo=require("socket.io")

这个第三方包与http服务器的区别是，http在每次获取到内容之后，客户端与服务器会断开连接，它每次连接，客户端和服务器都会存在三次握手的过程，而socket.io是长连接，它俩就只握一次手。只有有一方挂掉，另一方就会报错，它的好处是不用定期的去发送请求，只要服务器的数据发生改变，客户端就会实时的去更新数据。

方法1:var io=socketIo.listen(服务器)方法用来监听服务器。socketIo监听server服务器，即它可以监听到向服务器发起的所有请求（request.url），并且会将以soceket.io为开头的请求禁止。

这个方法的返回值是一个对象，这个对象下有一个事件，io.on("connection",function(socket ){ }), 这个事件是一个连接事件，这个事件的触发是在客户端引用了js文件之后，调用io.connect这个方法，取得与服务器的连接之后，服务器取得连接之后才会触发这个事件。回调函数中有一个socket对象，单词意思为插座，它是用于客户端和服务器之间的传递纽带。由于客户端不只一个，所以也会产生多个socket对象，而它是在客户端和服务器建立好连接之后才产生的对象。同时在这个事件中还有socket.on("disconnect",function( ){ })服务器与客户端断开连接的事件。还有socket.send( )这个方法，这个方法可以放任意数据类型。向客户端发信息。

还有socket.on("message",function(msg){ }) ,事件用来接收客户端发来的信息。

发送自定义事件：

1.socket 派发自定义事件

socket.emit("自定义事件名"，“派发内容”） 派发的内容可以是任意的数据类型。

\- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->区分客户端和服务器

客户端发起连接请求的JS文件：（在HTML中（客户端中）写的内容）

socket.io.js是socket.io服务器端以HTTP方式提供静态文件，所以在页面中可以直接用这个方式来请求服务器上的文件。

<script src="socket.io/socket.io.js"></script>(在html页面(客户端)中引入) 当连接了这个JS以后，它就会有一个方法 var socket=io.connect("http://localhost:8080") 用于客户端与服务器的连接，参数为服务器地址。这个方法的返回值同时可以触发多个自带事件：

1.socket.on("connect",function( ){ })  服务器和客户端成功连接的时候触发的事件

2.socket.on("disconnect",function( ){ })  服务器和客户端断开连接的时候触发的事件，判断连接是在ctrl+c之后。

3.socket.on("message",function(msg){ }) 这个事件是监听服务器发送给客户端的信息（但是服务器必须使用了send（）方法才会触发这个事件。）

4.socket.send( )方法是客户端向服务器发送信息

接收自定义事件：

1.socket.on("自定义事件名",function(内容){ })

## 框架 ——express 它是自身功能极简，完全是由路由和中间件构成的一个web开发框架 

Express是目前最流行的基于Node.js的Web开发框架，可以快速地搭建一个完整功能的网站。

express是一个非侵入式的框架。它是在http原有的基础上封装和扩展了很多的方法和属性，但是它没有修改http原有的一些方法。

一、下载+引入：（1）npm init  生成一个package. json的包管理文件 。

 （2）npm  install express --save 下载这个框架的第三方包  

（3）引入这个第三方包  var express=require("express")   

二、实例化express并把它挂载在一个叫做app的变量上：这个框架采用的是工厂模式， 所以直接调用即可。就是 var app=express（）； 其中app变量是application的简写，application是应用的意思。它是express 对象的一个实例。

三、注册路由：（可一次注册多个路由）

路由的概念：路由（Routing）是由一个特定的 HTTP 方法（GET、POST 等）和一个 URL（或者叫路径）组成的。

功能：涉及到应用（app）如何响应（res.end）客户端对某个网站节点(req.url)的访问。（白话：就是客户端的路径和服务器的路径相同时，执行回调函数里面的内容响应到客户端上。）

语法：app.method（url，function(request,response,next) { }）；//注册路由

​           app.listen(端口号，function( ){ //这个回调函数是可选参数 } )；//监听端口号

（1）app是一个express的实例

（2）mehod代表http请求的方式，我们常用的有post和get，还有put、delete、all等。我们常用的就是post和get，还有一种特殊的方式all。

（3）url代表服务器端的路径（也就是注册好的路由路径）。路由路径，它可以是字符串、字符串模式或者正则表达式。

例如：①：字符串模式。？问号类似与正则，表示？前的字符可以有1个或者没有。

app.get(“/ab?cd”， function (req, res) {

res.end('ab?cd');   //表示字母b可以匹配0次或者1次。

});

②：字符串模式。+加号类似与正则，表示+前的字符可以有1个或者多个。

app.get(“/ab+cd”， function (req, res) {

res.end('ab+cd');   //表示字母b可以匹配1次或者多次。

});

③：字符串模式。*星号，表示*前的字符开头，*后的字符结尾。

app.get(“/ab*cd”， function (req, res) {

res.end('ab*cd');   //表示匹配ab开头，cd结尾的地址参数。

});

④：字符串模式。（）括号表示分租匹配，在加上？也就是或匹配括号内的0次到1次。

app.get('/ab(cd)?e', function (req, res) {

res.end('ab(cd)?e');  //表示字母cd可以匹配0次或者1次。

});

⑤：正则模式。匹配任何路径中含有 a 的路径：

app.get(/a/, function (req, res) {

res.end('/a/');  //表示只要路径中必须有a字符就可以匹配到

});

⑥：正则模式。匹配 以fly结尾的路由路径  $以谁结尾。

app.get(/.*fly$/, function (req, res) {

res.end('/.*fly$/');   //表示只要路径中以fly结尾就可以匹配到

});

（4）最后的回调函数是当路由路径匹配到的时候需要执行的函数（也叫路由句柄）。每一个路由都可以有一个或者多个处理器函数，也就是后面的回调函数可以有一个或者多个。但是必须保证有一个。这个回调函数必须是当客户端请求的路径（浏览器输入的路径）与服务器上的路径匹配一致的时候执行。否则会在页面显示例如：Cannot GET /list  就是找不到get请求的/list的文件。

这个回调函数的行为类似中间件。唯一的区别是这些回调函数有可能调用 next('route') 方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有路径上继续执行没有意义，则可将控制权交给剩下的路径。

路由句柄有多种形式，可以是一个函数function(req,res,next){ }、一个函数数组，或者是两者混合

\- - - - - - - - - >回调中的参数：req，res，next

1.参数req，（全称是request）它表示请求对象。我们重点学习它的几个新增的属性：

★ req.url     表示请求路径，它是带有查询参数的。

★ req.path  这是个express框架给request新增的一个属性，它就等于我们原来url.parse(req.url).pathname也就是端口号和问号之间的那部分内容（路径）  当只需要路径不要后面的查询参数的时候就可以用这个属性。注：而我们在注册路由要匹配服务路径的时候，就是提取客户端的req.path与服务器地址匹配的，只有这两个地址完全一直，才会触发回调。

★ req.query 提取查询参数。返回地址栏参数中不包含问号，是问号之后的查询字符串的部分并转为对象例如？name=zs就会转为｛name:zs｝

★ req.params  其中params是参数的意思，这个属性会返回一个对象，对象的键名是路由路径，键名是在浏览器请求的时候赋的值。当路由路径参数中有冒号的时候可以用这个属性。例如："/user/:name/:age   name 和age是键值，在浏览器对应输入的是键名。 

2.参数res，（全称是response）它表示响应对象。我们重点学习它的几个新增的属性：

★ res.setHeader('Content-type'：'text/html；charset=utf-8' )  设置响应头信息

★ res.status( ) 设置响应状态码  例如： 400表示错误的请求

其中res的响应方式共10中：

※ 1）. res.end（） 可以设置响应内容，并结束响应。只能放字符串和buffer

※ 2）. res.send（） 发送各种类型的响应。类型是指对象，数组，字符等基本的数据类型，但是buffer是不可以响应的。注：当参数为数字时候，会默认为是状态码。所以尽量不要用这个方式发送数字。

※ 3）.res.sendFile（）  以八位字节流的形式发送文件。参数是要读取的文件，但是必须是绝对路径。所以就可以引入path模块，利用resolve或者是join去追加成为绝对路径。

※ 4）. res.download（） 提示下载文件。参数是要下载的内容，它是将文件从服务器下载到本地

※ 5）. res.json（） 发送一个 JSON 格式的响应。

※ 6）.  res.jsonp（） 发送一个支持 JSONP 的 JSON 格式的响应。就是可以响应跨域的

※ 7）. res.redirect（） 重定向请求。有就是当路由名称不相同的时候，就利用这个方法来跳转路由。这个方法的参数为要跳转的路由名。

※ 8）.res.render（） 渲染视图模板。ejs是一个视图模版。

※ 9）.res.sendStatus（） 设置响应状态代码，并将状态码以字符串形式作为响应体的一部分发送。

※ 10）.res.status（）.send （） 链式调用  自定义状态码和错误信息

3.参数next，它是一个函数next（），也是一个中间件。它的功能是移交控制权的。当前一个路由不想结束响应的时候就是不res.end( )的时候，而调用了next（），就表示将控制权交给下一个同名（名称必须相同）的路由。注：如果不结束响应，也不调用next，客户端就会一直挂起。所以必选填一个。

当一个路由有多个回调函数的时候，也可调用next( )方法，将控制权移交给下一个处理的回调函数。所以next()是将控制权交给下一个回调（处理器）函数或下一个同名路由的。

  注：当同时存在多个回调函数，也有同名的路由的时候，next（）会优先将控制权移交给距离自身最近的回调函数。

当next（）方法传了参数“route”，route是路由的意思。next('route'); 就表示跳过中间回调（处理器）函数，直接将控制权交给下一个同名路由。

总结：当next（）不传参数的时候是将控制权交给下一个处理器函数，当参数为“route”的时候是将控制权交给下一个同名的路由，当参数为err的时候是将控制权交给下一个错误处理中间件。

（5）app.listen( )监听端口号。

四、特殊的请求方式：app.all(url，function(req，res，next) { }) 

app.all() 是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。它不管你的请求方式是post还是get，只要客户端的请求地址和服务器地址一致就会触发后面的回调函数。 注：它不属于http请求。

五、fom表单的前后台交互：也就是登录名和密码的验证，求方式分为get和post两种：

1.get：获取get方式 是要操作地址栏的查询参数的就要用到res.query，它会自动将地址栏的查询参数转为一个对象。

2.post:获取post方式，就要用到req.on("data",function(chunk){//chunk是个buffer格式的}）事件和req.on("end",function(){})事件。因为post传输的数据有可能比极大，所以我们利用on（“end”）事件去分段发送。

五、注册路由的几种方式：

1.app.route（）创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。当注册同一个路由，拆分多种请求方式的时候用这个个方式（也就是常用于路由路径一致，而请求方式不同的时候）。

语法：app.route(url)   

​                 .method1(function (req, res, next) { })

​                 .method2(function (req, res, next) { })

​           app.listen（端口号）;  

其中，url参数指服务器端的路径。mehod代表http请求的方式。

2.express.Router（），可使用 express.Router 类创建模块化、可挂载的路由句柄。

这个方法必须挂载至应用。应用就是我们的app。这个方法常用于中间路由。

使用方式是var router=express.Router（）;

router.get("/",function(req,res){ });

app.use(router)  //就是将router挂载到app上。  必须挂载。注：app.use( )可以接收两个参数，第一个参数为可选参数，为虚拟的路由路径。第二个参数为router方式注册的路由。

★★★★★★★★六、中间件：

Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。

概念：中间件（Middleware） 是一个函数，它可以访问请求对象（request  (req)）, 响应对象（response (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。简单说，中间件就是处理HTTP请求的函数。它最大的特点就是，一个中间件处理完，再传递给下一个中间件。App实例在运行过程中，会调用一系列的中间件。每个中间件可以从App实例，接收三个参数，依次为request对象（代表HTTP请求）、response对象（代表HTTP回应），next回调函数（代表下一个中间件）。每个中间件都可以对HTTP请求（request对象）进行加工，并且决定是否调用next方法，将request对象再传给下一个中间件。

特点：中间件的两个特点：1、中间件是个函数      2、可以访问req, res, next。

中间件的功能包括：1.执行任何代码。2.修改请求和响应对象。3.终结请求-响应循环。  就是调用res.end( )等响应方法。4.调用堆栈中的下一个中间件。就是通过next函数去调用下一个中间件。

※：如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则来自客户端的请求就会挂起。

中间件分为：

1.应用级中间件    绑定到app上

应用级中间件绑定到 app 对象上。使用 app.use() 和 app.METHOD()方法去绑定， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, POST, PUT 等等，全部小写。

★ app.use( )这个方法可以接收两个参数，第一个参数为可选参数，为虚拟的路由路径。后面的参数可以为一个到多个的回调函数。而这些函数就被成为应用级中间件。只有这个方法可以有路径也可以没有路径。

注：1.没有挂载路径的中间件，应用的每个请求都会执行该中间件 例如：app.use(function (req, res, next) {   console.log('Time:', Date.now());   next(); });   这个挂载应用中间件没有路径，所以在客户端响应的端口号下，输入任何路径都会执行中间件里的内容。

app.listen(8080)

2.当挂载了路径的中间件的时，只要请求的根路径和挂载的路径的相同，就会执行中间件的内容。并且在根路径的后面跟任何别的路径都可以执行中间件，只要保证根路径是一致的就可以。例如：挂载路径为：/list，那么请求的路径为/list/a/b等都可以执行中间件，只要保证/list的根路径一直就可以。



2.路由级中间件  绑定到express.Router上

路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router()。

var router= express.Router( );

语法是：router.use( )或router.method ( )，method就是get和post等。但是一定要记住的是，在监听之前，一定要用app.use(router)，就是用app应用去挂载router。除此之外所有的表现形式都和应用中间件相同。

例如：router.use(function(req,res,next){

  res.end("hello");

};

app.use(router);   //这一步很重要

app.listen(8080)



3.错误处理中间件  绑定在app应用上。好处是拦截异常，友好的向客户端提示错误信息。

错误处理中间件有 4 个参数，分别为：err、req、res、next。参数err是一个错误对象，它有一个属性err.message，就是指错误的信息。定义错误处理中间件时必须使用这 4 个参数。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。

语法：app.use(路径，function(err,req,res,next){})   //里面的函数就是错误处理中间件，参数路径也是可有可无的。

要知道这个错误处理中间件是捕捉错误路由的。当别的路由在执行的时候发生了错误，那么这个错误的中间件就会捕捉到错误信息。就会执行函数中的内容。当没有错误发生时候，这个函数是不会被执行的。

还有一种错误是：如果客户端请求的是未注册的路由（注：未注册的路由不会走到错误中间件中，只有路由发生错误，才会走到错误中间件），那么需要友好的返回客户端不存在的信息，所以我们要处理的错误有两种：1.未注册的路由（它走的是应用中间件，且不能有路径app.use），需要向客户端友好的返回not found等错误信息。2.捕捉路由中发生的未预期的异常（它走错误中间件），比如语法错等等，如果不捕捉异常的话就会直接报错，所以我们可以捕捉异常，并返回服务器异常等信息。

★ 如何将这两种错误合二为一，将这两种错误都走错误中间件，而不走应用中间件：

app.use(function (req, res, next) {  //这个是没有注册过的路由

​    // 1、定义错误 

​    var err = new Error('您访问的页面不存在!');    

​    err.status = 404;      //手动给err对象添加状态码的键值队

​    //  2、传递错误

​    next(err);    // 将控制权交给下一个错误处理中间件

});

app.use(function (err, req, res, next) {  //错误处理中间件

​    // 3、响应错误

​    res.status(err.status || 500);

​    if (err.status) {

​        res.send(err.message);   //未注册

​    } else {

​        res.send('服务器端异常!请稍候再试!');  //捕捉到异常的时候

​    }

});

app.listen(8080);



4.内置中间件  express自带的中间件

（中间件就是方法，express是一个对象，内置中间件就是express下的某个方法）

express.static(root, options)

参数 root 指提供静态资源的根目录。

options是可选填的参数，它拥有很多属性（详看<http://www.expressjs.com.cn/guide/using-middleware.html>，官网查看）

express.static 是 Express 唯一内置的中间件。它基于 serve-static，负责在 Express 应用中提托管静态资源。

注：一定要利用app.use( )这个方法去挂载：app.use(express.static("./")); 并且 静态资源的这个方法可以多次调用



5.第三方中间件

通过使用第三方中间件从而为 Express 应用增加更多功能。

安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载。

（1）bodyParser中间件  

这是一个第三方包，但是在下载express的时候已经就依赖了，已经下载好。直接引入引用即可。

var bodyParser=require("body-parser")；

它用来解析http请求体（专用于post方式提交过来的数据），是express默认使用的中间件之一。

它地下有一个bodyParser.urlencoded（）方法则是用来解析我们通常的form表单post提交的数据的。当参数为｛extended：false｝的时候，键值对中的值就为'String'或'Array'形式，当为true的时候，则可为任何数据类型。而这个方法如果挂载在app.use上，例如：app.use(bodyParser.urlencoded({ extended: false }))；那么也就是说不论是post方式还是get方式都会经过这个路由，有点太浪费资源，所以我们就将它挂载在需要使用他的地方，比如post的路由上，例如：app.post(bodyParser.urlencoded({extended:false})，function(req,res,next){

console.log(req.body)；

})；

当加载了这个第三方的中间件，并挂载了urlencoded 的方法，那么在req会产生一个专门针对post请求的一个body属性：req.body，它就可以获取post 发送的请求数据。

## EJS 它是JavaScript模板库，用来从JSON数据中生成HTML字符串

它的工作原理：我们看到的数据是由后台服务器JSON和前端的EJS模版组成的。

![img](D:/YoudaoNote/y5iddy@163.com/5ff79fa0bb1946fc9086479a818aa150/clipboard.png)



EJS的用法：

1.要搭配express  所以首先引入var express=require("express")；var app=express（）；

2.下载ejs的第三方包，可以批量下载，在下载package.json之后，打开文件在里面添加

"devDependencies": {

​        "express": "*",

​        "ejs": "*"

​    },  然后直接npm install即可下载好express和ejs。

3.新建一个以ejs为后缀名的文件。

4.设置加载路径

app.set("views"，process.cwd( )+"views")；默认设置

app.set("views"，require("path").resolve("views))； 相同方法。

这个方法是在不想res.render（）中设置路径的时候，使用的。

5.设置模版的引擎（也就是设置文件后缀）

app.set("view engine","ejs")  将后缀名称设置为.ejs，也就是说在响应的时候，直接写文件名字就可以，可以省略后缀名称。

注：app.engine('.html', require("ejs").__express)  //当读取的文件为html的时候还要设置上这个

6.渲染视图模版，响应方式应为res.render（） 来响应ejs为后缀名的文件。

这个方法的第一个参数最好为绝对路径。或者将.ejs的文件放在一个叫做views的文件夹内。

因为当你不写绝对路径的时候，会默认到本地去查找叫views的文件夹。所以也可以调用第四步去设置加载路径。同时调用第五步设置文件的后缀，就不需要写绝对路径和后缀名称，直接写文件的名字就好，当然也可以不调用前两步的方法，但是这个响应的时候，就需要设置绝对路径和文件的后缀名称。第二参数为一个可选参数，它是一个对象，用来存放传递给前端的数据的方式之一，对象中的键值队可以根据需求，随意取名称。

7.传递数据的第二种方式：res.locals属性，它本身是一个空对象，所以我们就用它来当容器，将这个容器中的值传递到所渲染的模版引擎中（也就是后缀为.ejs的文件中）例如：

res.lcoals.tit="list"或者res.locals={title:"list",age:12}  两种方法都可以。

8.传递数据的第三种方式：app.locals  应用下的locals属性。这种方式是在传递公共用的数据的时候，应用这种方式。挂载在app上。

注：locals是Express应用中 Application(app)对象和Response(res)对象中的属性，该属性是一个对象。该对象的主要作用是，将值传递到所渲染的模板中。 一旦设定，app.locals的各属性值将贯穿程序的整个生命周期，与其相反的是res.locals，它只在这次请求的生命周期中有效。

app.locals定义可以应用整个生命周期中使用的变量

9.后缀名称为ejs的文件如何进行渲染：要记住只要换行的时候也是必须<%开头，%>结尾。

（1）<%js语法%>   用来解析JS语法

（2）<%=data%>   转义输出  就是输出键值

（3）<%-"data"%>  非转义输出   就是输出键名 

（4）<%include 要引入的文件名%>  引入别的.ejs文件。对多次使用的文件可以进行封装，然后引入使用。多个ejs可以嵌套使用。

ejs的文件，可以进行排版，样式与HTML文件的区别就是数据传递。ejs在数据传递上是非常方便的。



区分服务器响应页面的几种方式   

前三种方式是先让服务端对客户端响应了页面，由客户端在向服务端发送ajax请求，服务端在返回json数据，客户端再将json渲染到html页面。

最后一种方式可以直接使用ejs渲染模版。并且传递数据

1.res.end(fs.readFileSync( ) );

2.res.send(fs.readFileSync( ).toString( )) 注：send方法不支持Buffer格式的。

3.res.sendFile("./index.html")

4.res.render("index"，｛后台传送给前端的数据内容｝)  不仅可以响应页面 也可以传送数据。

## MySQL  第三方包——用于连接并操作数据库

什么是数据库？

数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。

创建自己的数据库要注意的事项：1.库名不用使用中文。要设置为utf8_bin，防止中文乱码。2.创建数据表，根据需求创建列数，当然这个列数可以在以后随意的增加和删除。但是要注意数据库和数据表的区别：首先数据库是一个很大的容器，我们要在数据库中创建很多的数据表。

3.在创建数据表的时候要注意一些选项，INT代表整型的数字，VARCHAR代表字符串，要根据需求，设置对应的选项。同时为方便区分使用，最好一个建立ID,同时将ID设置为PRIMARY主键，设定后，id具有唯一性，且不可以同时设定多个id的列名。最好在给id设置一个选项auto_increment，它会让id自动增长。



通过sql语句实现增添改查的效果：一定要熟记，不能将单词写错。

1.插入：insert into 表名（列名1，列名2）values（值1，值2）。注：输入字符串的时候一定要加引号  。WampServer好像需要大写。

2.删除：delete from 表名 where 条件。 注：条件一定要是列名=值。不能光是列名，服务器会自动将满足条件的选项删除。

3.更新：update 表名 set  列名1=值1，列名2=值2 where 范围。 注：修改多个列的时候用逗号隔开。

4.查询：

（1）查询全部：select * from 表名。注：*代表全部的意思。

（2）按照条件查询：select * from 表名 where 条件。注：条件一定要是列名=值

（3）按照列查询：select 列名 from 表名 where 条件

（4）模糊查询：select * from 表名 where 列名 like  ‘%value%’     查询列中带有value 的

​      select * from 表名 where 列名 like    ‘value%’      查询列中以value开头的 

​      select * from 表名 where 列名 like    ‘%value’      查询列中以val ue结尾的 

5.排序：select * from 表名 order by 列名  升序

​       select * from 表名 order by 列名  desc  倒序

\6. 查询中，当有多个条件值的时候：select * from 表名 where  列名1=值1 and 列名2=值2     列与列之间用and隔开

注：sql语句很多，更多详细查看<http://blog.csdn.net/znyyjk/article/details/52717336>

\7. 点击加载： 限制加载条数的语句：SELECT * FROM 表名 limit 开始，条数   

如何通过代码连接数据库，并操作数据库：

[1.下载加引入](http://blog.csdn.net/znyyjk/article/details/52717336) mysql这个第三方包：

（1）npm init  生成一个package. json的包管理文件 。 （2）npm  install mysql --save 下载这个第三方包  （3）引入这个第三方包  var myql=mysql("mysql")  

2.与数据库建立连接：使用第三方包中的createConnection( )方法，这个方法返回一个连接对象，

var connection=mysql.createConnection( )  ,它的参数可以接收一个对象，对象的内容为与你数据库连接的相关信息。

相关字段要记住：例如：var connection=createConnection({

host："localhost"        //域名：本地数据库还是远程数据库

port：3306   //端口：数据库的端口全部为3306

user ：“root”  //用户名，默认都为root

password：“”  //密码：一定要记住是字符串形式的。当你没有设置密码的时候，这个字段可以不写。

database：“chengyan”   //数据库名称

insecureAuth:true   // 安全证书：当连接不成功的时候，可以尝试这是这个和电脑的系统有关，一般不设置

})

判断是否连接成功 可以使用connection.connect()方法，这个方法可以放置一个回调函数，它会在连接成功时候触发，参数为err，例如：

connection.connect(function(err){

console.log(err)   //如果err返回null  则表示连接成功，如果返回错误对象表示连接失败

})

3.操作数据库中的数据表：

使用操作数据表的方法:connection.query(sql ，function(err，result，field){ })

第一个参数为sql语句

第二个参数为当执行问sql语句之后，会触发的回调函数，函数返回查询信息的结果，这个回调函数接收三个参数（1）err是错误对象，如果查询失败或sql语句错误的时候，会返回错误的信息。如果灭有错误发生返回的null（2）result  是返回的结果集，它分为A:undefined（当sql语句写错的时候会返回undefined）B:[ { } ] 数组对象，当是查询语句的时候，返回的肯定是一个数组对象。C:当不是查询语句的时候，返回的是一个对象，（3）field是指每一列的详细信息。为一个可选参数。



补充：下载 npm  install  node-dev -g    全局下载node-dev  也是用来运行js文件  用来解决当js文件修改一次重启一次终端的问题。当下载过后，使用的方法就是将原来的 例如：node main 变成 node-dev main   就不会在发生修改一次重启一次终端的情况。它还有一个好处是守护子进程，当发生错误的时候不会退出终端。



项目工程目录的具体分类及作用：

1.入口文件，一般命名为app.js、main.js、index.js其中一种，不要随意的起名

2.通过npm init生成包管理文件package.json

3.批量下载所需第三方包等文件，通过npm install  自动生成node_modules的用于存放第三方包的目录。

4.存放视图模版的目录（就是存放页面的文件夹）。文件夹名设置为views，里面存放index.html、login.ejs、register.ejs等

5.存放静态资源的目录（就是存放外链的css或js等文件）。文件夹名设置为public或者static，里面存放style.css、jquery.js、image等。

6.存放路由的目录。文件夹名为router。

7.配置目录，文件夹名为config。它里面分为（1）配置数据库，文件名为configMysql.js   （2）配置路由，文件名为configRouter.js

## JSONP  也是用于前端向后台请求数据的一种方式   (get)

ajax和jsonp都是用于前后台交互的方式，区别在与ajax规定，服务器端的文件和前端的文件必须在同源环境下，同协议，同域名，同端口，只要有一个不同，就存在跨域，就无法请求成功。所以出现了jsonp。

概念：Jsonp(JSON with Padding) 是 json 的一种"使用模式"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。为什么我们从不同的域（网站）访问数据需要一个特殊的技术(JSONP )呢？这是因为同源策略。同源策略，它是由Netscape提出的一个著名的安全策略，现在所有支持JavaScript 的浏览器都会使用这个策略。这个策略就规定，只要协议、域名、端口有一个不相同就不可以发生交互。

jsonp的原理：使用script标签中的src属性，这个属性无跨域限制。

jsonp使用步骤：

客户端：- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

客户端原生获取方法：（1）动态创建script标签。var scipt=document.createElement("script")

（2）指定script的src属性下的属性值为某一服务器下的文件地址。（属性值就是当前请求数据的地址）。script.src="http://localhost:8080/index?calback=getData"；

（3）将script标签追加到页面。document.body.appendChild(script)

（4）定义一个函数接收后台返回值。（也就是接收数据）

注：1.src属性值=某一服务器下的文件地址 + ？callbacke=函数名   （这种格式区别于普通请求，后台会自动识别为跨域请求。同时JSONP是get方式的请求。）。2.jsonp属于get方式的请求。所以后台会从请求路径中将函数名提取出来，将其包裹json数据返回。例如：fn(json)（像函数调用） 这里的fn指定义的一个函数名。3.前端定义  fn（函数名） 函数接收返回值。

客户端 jQuery获取方法：引入jquery.js。jquery中请求后台数据的方式有 $.ajax（）、$.getJSON（）、$.get（）、$.post（），前两种方法可以跨域，而最后两种方法不可以跨域。

（1）$.ajax({                                //$.ajax（）并不是ajax只是jq封装的一种方法，通过dataType来设置方式是ajax还是jsonp等。

url:"http://localhost:8888/index"，             // ?callback=? ，当设置了dataType为jsonp的时候这个可以不写

dataType:"jsonp",     //向要设置为跨域的就必须设置个，当不设置的时候默认ajax

success:fuction(data){

}

})

（2）$.getJSON（'http://localhost:8888/index？callback=？'，function(data){}）

注：这个方法是通过URL来判断是ajax还是jsonp的，所以地址必须拼接？callback=？（jq会在解析的时候将最后的问号随机生成一个戳，也就是随机的函数名）

服务器响应：- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

服务器原生响应方法：引入express框架，搭建路由服务。响应数据。在服务器断返回数据响应应该用响应方式中的res.jsonp( );专门用来响应json的方法。而这种方法的实现原理就是：1：动态获取前端传来的函数名   方法有三种（1）通过对erq.url的截取。例如：var cbName=req.url.split("?callback=")[1]。（2）利用内置模块url。例如：var queryNanme=require('url').parse(req.url，true).query； var cbName=queryNanme.callback。（3）利用框架express中req.query方法。截取地址中的查询参数。例如var cbName=req.query.callback。

以上三种方法都需要在通过res.end(`typeof ${cbName} === "function" && ${cbName} (${JSON.stringify(data)})`)；响应给客户端。先判断cbName是否为函数，当为真的时候在去将函数名包裹数据，调用客户端定义好的函数。同时，在客户端假如没有定义函数的情况下也不会报错。因为第一个条件就不满足就回不在往后执行。

服务器 jQuery响应方法：（1）获取到JQ随机生成的函数名包括三中方式：①. 截取req.url，但是这种方法比较麻烦，需要截取两次 例如：var cbName = req.url.split('?callback=')[1].split('&_=')[0]；。②.利用内置模块url 。例如：  var query = require('url').parse(req.url, true).query；var cbName = query.callback;③利用express中的req.query。例如：var cbName = req.query.callback;

以上三种方法也都需要在通过res.end(`typeof ${cbName} === "function" && ${cbName}(${JSON.stringify(data)})`);响应给客户端。







### 一些方法

1. 读取文件的状态；
   ​    fs.stat(path,callback);
   ​      callback有两个参数；err，stats；stats是一个fs.Stats对象；
      如果发生错误err.code是常见错误之一；
      不建议在调用 fs.open() 、fs.readFile() 或 fs.writeFile() 之前使用 fs.stat() 检查一个文件是否存在。 作为替代，用户代码应该直接打开/读取/写入文件，当文件无效时再处理错误。
      如果要检查一个文件是否存在且不操作它，推荐使用 fs.access()。

2. 测试某个路径下的文件是否存在。 回调函数包含一个参数exists，true则文件存在，否则是false`.fs.exists(path, callback)`